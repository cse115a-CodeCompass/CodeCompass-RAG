{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA4FsB,2BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/orgService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient, createAdminClient } from \"@/utils/supabase/server\";\nimport {\n  Organization,\n  OrganizationWithRole,\n  OrganizationMember,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\n\nexport async function getOrgs(): Promise<ActionResult<OrganizationWithRole[]>> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  // Query from user_organizations table to properly filter by user_id\n  const { data: userOrgs, error: organizationsError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role,joined_at,organizations(id,name,created_at)\")\n    .eq(\"user_id\", user.id);\n\n  if (organizationsError) {\n    return { success: false, error: organizationsError.message };\n  }\n\n  // Transform the data to match OrganizationWithRole structure\n  const organizations: OrganizationWithRole[] = (userOrgs ?? []).map((uo) => {\n    const org = uo.organizations as Organization | Organization[];\n    // Handle case where organizations might be an array (shouldn't happen with proper FK)\n    const orgData = Array.isArray(org) ? org[0] : org;\n\n    return {\n      id: orgData.id,\n      name: orgData.name,\n      created_at: orgData.created_at,\n      role: uo.role,\n      joined_at: uo.joined_at,\n    };\n  });\n\n  return {\n    success: true,\n    data: organizations,\n  };\n}\n\nexport async function getOrgById(\n  orgId: string,\n): Promise<ActionResult<Organization>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  const { data: organization, error } = await supabase\n    .from(\"organizations\")\n    .select(\"id,name,created_at\")\n    .eq(\"id\", orgId)\n    .single();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  if (!organization) {\n    return { success: false, error: \"Organization not found\" };\n  }\n\n  return { success: true, data: organization };\n}\n\nexport async function getOrgMembers(\n  orgId: string,\n): Promise<ActionResult<OrganizationMember[]>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // Verify user has access to this organization\n  const { data: userOrg, error: accessError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id\")\n    .eq(\"organization_id\", orgId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (accessError || !userOrg) {\n    return { success: false, error: \"Access denied to this organization\" };\n  }\n\n  // Fetch all members of the organization with their user details\n  // Join with users table to get email addresses\n  const { data: members, error: membersError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"user_id, organization_id, role, joined_at, users(email)\")\n    .eq(\"organization_id\", orgId)\n    .order(\"joined_at\", { ascending: true });\n\n  if (membersError) {\n    return { success: false, error: membersError.message };\n  }\n\n  if (!members || members.length === 0) {\n    return { success: true, data: [] };\n  }\n\n  // Transform the joined data to match OrganizationMember type\n  const membersWithEmails: OrganizationMember[] = members.map((m) => {\n    // Handle the users field which could be an object or array due to the join\n    const userData = m.users as { email: string } | { email: string }[] | null;\n    const email = Array.isArray(userData)\n      ? userData[0]?.email || \"Unknown\"\n      : userData?.email || \"Unknown\";\n\n    return {\n      user_id: m.user_id,\n      organization_id: m.organization_id,\n      role: m.role as \"owner\" | \"teammate\",\n      joined_at: m.joined_at,\n      user_email: email,\n    };\n  });\n\n  return { success: true, data: membersWithEmails };\n}\n\nexport async function createOrg(\n  formData: FormData,\n): Promise<ActionResult<Organization>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Organization name is required\" };\n  }\n\n  const { data: organization, error: organizationError } = await supabase\n    .from(\"organizations\")\n    .insert({\n      name: name.trim(),\n    })\n    .select()\n    .single();\n\n  if (organizationError) {\n    return { success: false, error: organizationError.message };\n  }\n\n  const { error: userOrganizationError } = await supabase\n    .from(\"user_organizations\")\n    .insert({\n      user_id: user.id,\n      organization_id: organization.id,\n      role: \"owner\",\n    })\n    .select()\n    .single();\n\n  if (userOrganizationError) {\n    return { success: false, error: userOrganizationError.message };\n  }\n\n  return { success: true, data: organization };\n}\n\nexport async function createInviteLink(\n  organizationId: string,\n): Promise<ActionResult<{ token: string; expiresAt: string }>> {\n  const supabase = await createClient();\n\n  //authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  //check membership\n  const { data: userOrg, error: accessError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id, role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (accessError || !userOrg) {\n    return {\n      success: false,\n      error: \"User does not have access to this organization!\",\n    };\n  }\n\n  //generate a secure token\n\n  const token = crypto.randomUUID();\n\n  //calculate expiry date\n  const expiresAt = new Date();\n  expiresAt.setDate(expiresAt.getDate() + 7);\n\n  //store the invite in supa\n\n  const { error: inviteError } = await supabase\n    .from(\"organization_invites\")\n    .insert({\n      organization_id: organizationId,\n      created_by: user.id,\n      token,\n      expires_at: expiresAt.toISOString(),\n    });\n\n  if (inviteError) {\n    console.error(\"Failed to create invite:\", inviteError);\n    return { success: false, error: \"Failed to create invite link\" };\n  }\n\n  return {\n    success: true,\n    data: {\n      token,\n      expiresAt: expiresAt.toISOString(),\n    },\n  };\n}\n\nexport async function acceptInvite(\n  token: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return {\n      success: false,\n      error: \"You must be logged in to accept an invite\",\n    };\n  }\n\n  // 2. Fetch and validate invite (with locking to prevent race conditions)\n  const { data: invite, error: inviteError } = await supabase\n    .from(\"organization_invites\")\n    .select(\"*\")\n    .eq(\"token\", token)\n    .is(\"used_at\", null) // Only get unused invites\n    .single();\n\n  if (inviteError || !invite) {\n    return { success: false, error: \"Invalid or expired invite link\" };\n  }\n\n  // 3. Check expiration\n  const now = new Date();\n  const expiresAt = new Date(invite.expires_at);\n  if (now > expiresAt) {\n    return { success: false, error: \"This invite has expired\" };\n  }\n\n  // 4. Check if user is already a member\n  const { data: existingMembership } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id\")\n    .eq(\"organization_id\", invite.organization_id)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (existingMembership) {\n    return {\n      success: false,\n      error: \"You are already a member of this organization\",\n    };\n  }\n\n  // 5. Add user to organization\n  const { error: membershipError } = await supabase\n    .from(\"user_organizations\")\n    .insert({\n      user_id: user.id,\n      organization_id: invite.organization_id,\n      role: \"teammate\", // Default role for invited users\n    });\n\n  if (membershipError) {\n    console.error(\"Failed to add user to organization:\", membershipError);\n    return { success: false, error: \"Failed to join organization\" };\n  }\n\n  // 6. Mark invite as used (using admin client with secret key to bypass RLS)\n  const adminClient = createAdminClient();\n  const { error: updateError } = await adminClient\n    .from(\"organization_invites\")\n    .update({\n      used_at: new Date().toISOString(),\n      used_by: user.id,\n    })\n    .eq(\"token\", token);\n\n  if (updateError) {\n    console.error(\"Failed to mark invite as used:\", updateError);\n    // Don't return error - user was already added successfully\n  }\n\n  return {\n    success: true,\n    data: { organizationId: invite.organization_id },\n  };\n}\n\nexport async function removeMemberFromOrg(\n  organizationId: string,\n  userIdToRemove: string,\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify current user is an owner (RLS will also enforce this)\n  const { data: currentUserRole, error: roleError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (roleError || !currentUserRole || currentUserRole.role !== \"owner\") {\n    return {\n      success: false,\n      error: \"Only organization owners can remove members\",\n    };\n  }\n\n  // 3. Check if the user being removed is the last owner\n  if (userIdToRemove === user.id) {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot remove the last owner from the organization\",\n      };\n    }\n  }\n\n  // 4. Remove the member (RLS policy will enforce owner permission)\n  const { error: deleteError } = await supabase\n    .from(\"user_organizations\")\n    .delete()\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToRemove);\n\n  if (deleteError) {\n    return { success: false, error: \"Failed to remove member\" };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function leaveOrganization(\n  organizationId: string,\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify user is a member of this organization\n  const { data: membership, error: membershipError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (membershipError || !membership) {\n    return {\n      success: false,\n      error: \"You are not a member of this organization\",\n    };\n  }\n\n  // 3. If user is an owner, check if they're the last owner\n  if (membership.role === \"owner\") {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot leave as the last owner. Transfer ownership first.\",\n      };\n    }\n  }\n\n  // 4. Remove the user from the organization\n  const { error: deleteError } = await supabase\n    .from(\"user_organizations\")\n    .delete()\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id);\n\n  if (deleteError) {\n    return { success: false, error: \"Failed to leave organization\" };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function updateMemberRole(\n  organizationId: string,\n  userIdToUpdate: string,\n  newRole: \"owner\" | \"teammate\",\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify current user is an owner\n  const { data: currentUserRole, error: roleError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (roleError || !currentUserRole || currentUserRole.role !== \"owner\") {\n    return {\n      success: false,\n      error: \"Only organization owners can change member roles\",\n    };\n  }\n\n  // 3. Get current role of user being updated\n  const { data: targetUser, error: targetError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToUpdate)\n    .single();\n\n  if (targetError || !targetUser) {\n    return { success: false, error: \"Member not found\" };\n  }\n\n  // 4. If demoting from owner to teammate, check if they're the last owner\n  if (targetUser.role === \"owner\" && newRole === \"teammate\") {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot demote the last owner. Promote another member first.\",\n      };\n    }\n  }\n\n  // 5. Update the role\n  const { error: updateError } = await supabase\n    .from(\"user_organizations\")\n    .update({ role: newRole })\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToUpdate);\n\n  if (updateError) {\n    return { success: false, error: \"Failed to update member role\" };\n  }\n\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAiFsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/hooks/usePrefetchRoute.ts"],"sourcesContent":["\"use client\";\n\nimport { useRouter } from \"next/navigation\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { getOrgMembers } from \"@/lib/services/orgService\";\nimport { getReposByOrganizationId } from \"@/lib/services/repoService\";\n\n/**\n * Custom hook for prefetching routes and their associated data\n * Combines Next.js route prefetching with React Query data prefetching\n */\nexport function usePrefetchRoute() {\n  const router = useRouter();\n  const queryClient = useQueryClient();\n\n  /**\n   * Prefetch organization page (route + repos data)\n   */\n  const prefetchOrgPage = (orgId: string) => {\n    // Prefetch the route bundle\n    router.prefetch(`/dashboard/org/${orgId}`);\n\n    // Prefetch repositories data\n    queryClient.prefetchQuery({\n      queryKey: [\"repositories\", orgId],\n      queryFn: async () => {\n        const result = await getReposByOrganizationId(orgId);\n        if (!result.success) {\n          throw new Error(result.error);\n        }\n        return result.data;\n      },\n      staleTime: 2 * 60 * 1000, // 2 minutes\n    });\n  };\n\n  /**\n   * Prefetch team page (route + members data)\n   */\n  const prefetchTeamPage = (orgId: string) => {\n    // Prefetch the route bundle\n    router.prefetch(`/dashboard/org/${orgId}/team`);\n\n    // Prefetch members data\n    queryClient.prefetchQuery({\n      queryKey: [\"members\", orgId],\n      queryFn: async () => {\n        const result = await getOrgMembers(orgId);\n        if (!result.success) {\n          throw new Error(result.error);\n        }\n        return result.data;\n      },\n      staleTime: 2 * 60 * 1000, // 2 minutes\n    });\n  };\n\n  /**\n   * Prefetch organizations list page (route + orgs data)\n   */\n  const prefetchOrganizationsPage = () => {\n    router.prefetch(\"/dashboard/organizations\");\n    // Orgs data is already prefetched by the page, so we just prefetch the route\n  };\n\n  /**\n   * Prefetch repository page (route only)\n   */\n  const prefetchRepoPage = (repoId: string) => {\n    // Prefetch the route bundle\n    router.prefetch(`/dashboard/repo/${repoId}`);\n    // TODO: Add data prefetching when repo page services are implemented\n  };\n\n  return {\n    prefetchOrgPage,\n    prefetchTeamPage,\n    prefetchOrganizationsPage,\n    prefetchRepoPage,\n  };\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AACA;;AALA;;;;;AAWO,SAAS;;IACd,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,cAAc,IAAA,2MAAc;IAElC;;GAEC,GACD,MAAM,kBAAkB,CAAC;QACvB,4BAA4B;QAC5B,OAAO,QAAQ,CAAC,CAAC,eAAe,EAAE,OAAO;QAEzC,6BAA6B;QAC7B,YAAY,aAAa,CAAC;YACxB,UAAU;gBAAC;gBAAgB;aAAM;YACjC,SAAS;gBACP,MAAM,SAAS,MAAM,IAAA,6LAAwB,EAAC;gBAC9C,IAAI,CAAC,OAAO,OAAO,EAAE;oBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;gBAC9B;gBACA,OAAO,OAAO,IAAI;YACpB;YACA,WAAW,IAAI,KAAK;QACtB;IACF;IAEA;;GAEC,GACD,MAAM,mBAAmB,CAAC;QACxB,4BAA4B;QAC5B,OAAO,QAAQ,CAAC,CAAC,eAAe,EAAE,MAAM,KAAK,CAAC;QAE9C,wBAAwB;QACxB,YAAY,aAAa,CAAC;YACxB,UAAU;gBAAC;gBAAW;aAAM;YAC5B,SAAS;gBACP,MAAM,SAAS,MAAM,IAAA,kLAAa,EAAC;gBACnC,IAAI,CAAC,OAAO,OAAO,EAAE;oBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;gBAC9B;gBACA,OAAO,OAAO,IAAI;YACpB;YACA,WAAW,IAAI,KAAK;QACtB;IACF;IAEA;;GAEC,GACD,MAAM,4BAA4B;QAChC,OAAO,QAAQ,CAAC;IAChB,6EAA6E;IAC/E;IAEA;;GAEC,GACD,MAAM,mBAAmB,CAAC;QACxB,4BAA4B;QAC5B,OAAO,QAAQ,CAAC,CAAC,gBAAgB,EAAE,QAAQ;IAC3C,qEAAqE;IACvE;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GArEgB;;QACC,kJAAS;QACJ,2MAAc"}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/repos/card.tsx"],"sourcesContent":["\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { FolderCode, ChevronRight } from \"lucide-react\";\nimport { Github } from \"@geist-ui/icons\";\nimport { Gitlab } from \"@geist-ui/icons\";\nimport { Repo } from \"@/app/types/supabase\";\nimport { useRouter } from \"next/navigation\";\nimport { usePrefetchRoute } from \"@/hooks/usePrefetchRoute\";\nimport { motion } from \"framer-motion\";\n\ntype RepoButtonProps = {\n  repo: Repo;\n};\n\nexport function RepoButton({ repo }: RepoButtonProps) {\n  const router = useRouter();\n  const type = repo.provider;\n  const index_status = repo.index_status;\n  const { prefetchRepoPage } = usePrefetchRoute();\n\n  return (\n    <motion.div whileHover=\"hover\" className=\"parent\">\n      <Button\n        variant=\"outline\"\n        className=\"bg-background h-auto min-h-21 justify-start p-4 w-full hover:bg-elevated\"\n        onClick={() => router.push(`/dashboard/repo/${repo.id}`)}\n        onMouseEnter={() => prefetchRepoPage(repo.id)}\n      >\n        <div className=\"flex flex-row gap-4 text-sm w-full overflow-hidden\">\n          {/* Surround in a circular container */}\n          <div className=\"rounded-full dark:bg-black border-2 border-primary p-2.5 shrink-0\">\n            {type === \"github\" ? (\n              <Github className=\"w-4 h-4\" />\n            ) : type === \"gitlab\" ? (\n              <Gitlab className=\"w-4 h-4\" />\n            ) : (\n              <FolderCode className=\"w-4 h-4 text-white\" />\n            )}\n          </div>\n          <div className=\"flex flex-col justify-start items-start min-w-0 flex-1\">\n            <span className=\"font-semibold truncate\">{repo.name}</span>\n            <span className=\"text-muted-foreground text-xs whitespace-nowrap\">\n              {type === \"github\"\n                ? \"GitHub\"\n                : type === \"gitlab\"\n                  ? \"GitLab\"\n                  : \"Local\"}{\" \"}\n              <span className=\"text-md\">&middot;</span>{\" \"}\n              {index_status || \"Not Indexed\"}\n            </span>\n          </div>\n          <motion.div\n            initial={{ opacity: 0.5 }}\n            variants={{ hover: { x: 4, opacity: 1 } }}\n          >\n            <ChevronRight className=\"text-primary-foreground\" />\n          </motion.div>\n        </div>\n      </Button>\n    </motion.div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AAGA;AACA;AACA;;;AATA;;;;;;;;AAeO,SAAS,WAAW,EAAE,IAAI,EAAmB;;IAClD,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,OAAO,KAAK,QAAQ;IAC1B,MAAM,eAAe,KAAK,YAAY;IACtC,MAAM,EAAE,gBAAgB,EAAE,GAAG,IAAA,uJAAgB;IAE7C,qBACE,6LAAC,uMAAM,CAAC,GAAG;QAAC,YAAW;QAAQ,WAAU;kBACvC,cAAA,6LAAC,+IAAM;YACL,SAAQ;YACR,WAAU;YACV,SAAS,IAAM,OAAO,IAAI,CAAC,CAAC,gBAAgB,EAAE,KAAK,EAAE,EAAE;YACvD,cAAc,IAAM,iBAAiB,KAAK,EAAE;sBAE5C,cAAA,6LAAC;gBAAI,WAAU;;kCAEb,6LAAC;wBAAI,WAAU;kCACZ,SAAS,yBACR,6LAAC,4JAAM;4BAAC,WAAU;;;;;mCAChB,SAAS,yBACX,6LAAC,4JAAM;4BAAC,WAAU;;;;;iDAElB,6LAAC,mOAAU;4BAAC,WAAU;;;;;;;;;;;kCAG1B,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAK,WAAU;0CAA0B,KAAK,IAAI;;;;;;0CACnD,6LAAC;gCAAK,WAAU;;oCACb,SAAS,WACN,WACA,SAAS,WACP,WACA;oCAAS;kDACf,6LAAC;wCAAK,WAAU;kDAAU;;;;;;oCAAgB;oCACzC,gBAAgB;;;;;;;;;;;;;kCAGrB,6LAAC,uMAAM,CAAC,GAAG;wBACT,SAAS;4BAAE,SAAS;wBAAI;wBACxB,UAAU;4BAAE,OAAO;gCAAE,GAAG;gCAAG,SAAS;4BAAE;wBAAE;kCAExC,cAAA,6LAAC,yOAAY;4BAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMpC;GA/CgB;;QACC,kJAAS;QAGK,uJAAgB;;;KAJ/B"}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/ui/empty.tsx"],"sourcesContent":["// components/ui/empty.tsx\r\nimport { ReactNode } from \"react\";\r\n\r\ninterface EmptyProps {\r\n  title: string;\r\n  description?: string;\r\n  children?: ReactNode;\r\n  icon?: ReactNode;\r\n}\r\n\r\nexport function Empty({ title, description, children, icon }: EmptyProps) {\r\n  return (\r\n    <div className=\"flex flex-col items-center justify-center text-center py-12\">\r\n      {icon && <div className=\"mb-3 rounded-lg bg-muted p-2\">{icon}</div>}\r\n      <h3 className=\"text-lg font-semibold\">{title}</h3>\r\n      {description && (\r\n        <p className=\"text-sm text-muted-foreground mt-2\">{description}</p>\r\n      )}\r\n      {children && <div className=\"mt-4\">{children}</div>}\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;;;AAUnB,SAAS,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,EAAc;IACtE,qBACE,6LAAC;QAAI,WAAU;;YACZ,sBAAQ,6LAAC;gBAAI,WAAU;0BAAgC;;;;;;0BACxD,6LAAC;gBAAG,WAAU;0BAAyB;;;;;;YACtC,6BACC,6LAAC;gBAAE,WAAU;0BAAsC;;;;;;YAEpD,0BAAY,6LAAC;gBAAI,WAAU;0BAAQ;;;;;;;;;;;;AAG1C;KAXgB"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/repos/list.tsx"],"sourcesContent":["\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Repo } from \"@/app/types/supabase\";\nimport { getReposByOrganizationId } from \"@/lib/services/repoService\";\nimport { RepoButton } from \"./card\";\nimport { Empty } from \"@/components/ui/empty\";\nimport { Button } from \"@/components/ui/button\";\nimport Link from \"next/link\";\nimport { FolderPlus, Plus } from \"lucide-react\";\n\ntype RepoListProps = {\n  organizationId: string;\n};\n\nexport function RepoList({ organizationId }: RepoListProps) {\n  const { data, isLoading, error } = useQuery<Repo[]>({\n    queryKey: [\"repositories\", organizationId],\n    queryFn: async () => {\n      const result = await getReposByOrganizationId(organizationId);\n\n      if (!result.success) {\n        throw new Error(result.error);\n      }\n\n      return result.data as Repo[];\n    },\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (error) {\n    return <div className=\"text-destructive\"> Error: {error.message} </div>;\n  }\n\n  if (!data || data.length === 0) {\n    //where i'm gonna add the empty\n    // for /dashboard/new/${id} , figure out how to get the id\n    return (\n      <div className=\"flex justify-center items-center\">\n        <Empty\n          title=\"You Have No Repositories\"\n          description=\"Index a repository to get started\"\n          icon={<FolderPlus className=\"w-6 h-6 text-muted-foreground\" />}\n        >\n          <Button variant=\"default\" size=\"sm\">\n            <Link href={`/dashboard/new/${organizationId}`}>\n              <div className=\"flex items-center gap-1\">\n                <Plus />\n                <span>New repository</span>\n              </div>\n            </Link>\n          </Button>\n        </Empty>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6\">\n      {data.map((repo) => (\n        <RepoButton key={repo.id} repo={repo} />\n      ))}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AATA;;;;;;;;AAeO,SAAS,SAAS,EAAE,cAAc,EAAiB;;IACxD,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,IAAA,0LAAQ,EAAS;QAClD,UAAU;YAAC;YAAgB;SAAe;QAC1C,OAAO;iCAAE;gBACP,MAAM,SAAS,MAAM,IAAA,6LAAwB,EAAC;gBAE9C,IAAI,CAAC,OAAO,OAAO,EAAE;oBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;gBAC9B;gBAEA,OAAO,OAAO,IAAI;YACpB;;IACF;IAEA,IAAI,WAAW;QACb,qBAAO,6LAAC;sBAAI;;;;;;IACd;IAEA,IAAI,OAAO;QACT,qBAAO,6LAAC;YAAI,WAAU;;gBAAmB;gBAAS,MAAM,OAAO;gBAAC;;;;;;;IAClE;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;QAC9B,+BAA+B;QAC/B,0DAA0D;QAC1D,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC,6IAAK;gBACJ,OAAM;gBACN,aAAY;gBACZ,oBAAM,6LAAC,mOAAU;oBAAC,WAAU;;;;;;0BAE5B,cAAA,6LAAC,+IAAM;oBAAC,SAAQ;oBAAU,MAAK;8BAC7B,cAAA,6LAAC,0KAAI;wBAAC,MAAM,CAAC,eAAe,EAAE,gBAAgB;kCAC5C,cAAA,6LAAC;4BAAI,WAAU;;8CACb,6LAAC,6MAAI;;;;;8CACL,6LAAC;8CAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAOpB;IAEA,qBACE,6LAAC;QAAI,WAAU;kBACZ,KAAK,GAAG,CAAC,CAAC,qBACT,6LAAC,iKAAU;gBAAe,MAAM;eAAf,KAAK,EAAE;;;;;;;;;;AAIhC;GApDgB;;QACqB,0LAAQ;;;KAD7B"}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/navbar-context-setter.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useNavBarStore } from \"@/lib/stores/useNavbarStore\";\n\ninterface NavbarContextSetterProps {\n  contextText?: string;\n  breadcrumbs?: Array<{ label: string; href?: string }>;\n  appendBreadcrumb?: { label: string; href?: string };\n}\n\n/**\n * Client component that sets the navbar context.\n * Use this in Server Components to update the navbar state.\n *\n * @param contextText - Simple text to display (no breadcrumbs)\n * @param breadcrumbs - Complete breadcrumb trail (replaces existing)\n * @param appendBreadcrumb - Single breadcrumb to append to existing trail\n */\nexport function NavbarContextSetter({\n  contextText,\n  breadcrumbs,\n  appendBreadcrumb,\n}: NavbarContextSetterProps) {\n  const setContext = useNavBarStore((state) => state.setContext);\n  const setBreadcrumbs = useNavBarStore((state) => state.setBreadcrumbs);\n  const appendBreadcrumbAction = useNavBarStore(\n    (state) => state.appendBreadcrumb,\n  );\n  const reset = useNavBarStore((state) => state.reset);\n\n  useEffect(() => {\n    if (breadcrumbs) {\n      setBreadcrumbs(breadcrumbs);\n    } else if (appendBreadcrumb) {\n      appendBreadcrumbAction(appendBreadcrumb);\n    } else if (contextText) {\n      setContext(contextText);\n    }\n\n    // Clean up on unmount\n    return () => {\n      reset();\n    };\n  }, [\n    contextText,\n    breadcrumbs,\n    appendBreadcrumb,\n    setContext,\n    setBreadcrumbs,\n    appendBreadcrumbAction,\n    reset,\n  ]);\n\n  // This component doesn't render anything\n  return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;;AAHA;;;AAmBO,SAAS,oBAAoB,EAClC,WAAW,EACX,WAAW,EACX,gBAAgB,EACS;;IACzB,MAAM,aAAa,IAAA,2JAAc;0DAAC,CAAC,QAAU,MAAM,UAAU;;IAC7D,MAAM,iBAAiB,IAAA,2JAAc;8DAAC,CAAC,QAAU,MAAM,cAAc;;IACrE,MAAM,yBAAyB,IAAA,2JAAc;sEAC3C,CAAC,QAAU,MAAM,gBAAgB;;IAEnC,MAAM,QAAQ,IAAA,2JAAc;qDAAC,CAAC,QAAU,MAAM,KAAK;;IAEnD,IAAA,0KAAS;yCAAC;YACR,IAAI,aAAa;gBACf,eAAe;YACjB,OAAO,IAAI,kBAAkB;gBAC3B,uBAAuB;YACzB,OAAO,IAAI,aAAa;gBACtB,WAAW;YACb;YAEA,sBAAsB;YACtB;iDAAO;oBACL;gBACF;;QACF;wCAAG;QACD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,yCAAyC;IACzC,OAAO;AACT;GArCgB;;QAKK,2JAAc;QACV,2JAAc;QACN,2JAAc;QAG/B,2JAAc;;;KAVd"}}]
}