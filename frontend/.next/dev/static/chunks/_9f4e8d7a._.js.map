{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/orgService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient, createAdminClient } from \"@/utils/supabase/server\";\nimport {\n  Organization,\n  OrganizationWithRole,\n  OrganizationMember,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\n\nexport async function getOrgs(): Promise<ActionResult<OrganizationWithRole[]>> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  // Query from user_organizations table to properly filter by user_id\n  const { data: userOrgs, error: organizationsError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role,joined_at,organizations(id,name,created_at)\")\n    .eq(\"user_id\", user.id);\n\n  if (organizationsError) {\n    return { success: false, error: organizationsError.message };\n  }\n\n  // Transform the data to match OrganizationWithRole structure\n  const organizations: OrganizationWithRole[] = (userOrgs ?? []).map((uo) => {\n    const org = uo.organizations as Organization | Organization[];\n    // Handle case where organizations might be an array (shouldn't happen with proper FK)\n    const orgData = Array.isArray(org) ? org[0] : org;\n\n    return {\n      id: orgData.id,\n      name: orgData.name,\n      created_at: orgData.created_at,\n      role: uo.role,\n      joined_at: uo.joined_at,\n    };\n  });\n\n  return {\n    success: true,\n    data: organizations,\n  };\n}\n\nexport async function getOrgById(\n  orgId: string,\n): Promise<ActionResult<Organization>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  const { data: organization, error } = await supabase\n    .from(\"organizations\")\n    .select(\"id,name,created_at\")\n    .eq(\"id\", orgId)\n    .single();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  if (!organization) {\n    return { success: false, error: \"Organization not found\" };\n  }\n\n  return { success: true, data: organization };\n}\n\nexport async function getOrgMembers(\n  orgId: string,\n): Promise<ActionResult<OrganizationMember[]>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // Verify user has access to this organization\n  const { data: userOrg, error: accessError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id\")\n    .eq(\"organization_id\", orgId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (accessError || !userOrg) {\n    return { success: false, error: \"Access denied to this organization\" };\n  }\n\n  // Fetch all members of the organization with their user details\n  // Join with users table to get email addresses\n  const { data: members, error: membersError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"user_id, organization_id, role, joined_at, users(email)\")\n    .eq(\"organization_id\", orgId)\n    .order(\"joined_at\", { ascending: true });\n\n  if (membersError) {\n    return { success: false, error: membersError.message };\n  }\n\n  if (!members || members.length === 0) {\n    return { success: true, data: [] };\n  }\n\n  // Transform the joined data to match OrganizationMember type\n  const membersWithEmails: OrganizationMember[] = members.map((m) => {\n    // Handle the users field which could be an object or array due to the join\n    const userData = m.users as { email: string } | { email: string }[] | null;\n    const email = Array.isArray(userData)\n      ? userData[0]?.email || \"Unknown\"\n      : userData?.email || \"Unknown\";\n\n    return {\n      user_id: m.user_id,\n      organization_id: m.organization_id,\n      role: m.role as \"owner\" | \"teammate\",\n      joined_at: m.joined_at,\n      user_email: email,\n    };\n  });\n\n  return { success: true, data: membersWithEmails };\n}\n\nexport async function createOrg(\n  formData: FormData,\n): Promise<ActionResult<Organization>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Organization name is required\" };\n  }\n\n  const { data: organization, error: organizationError } = await supabase\n    .from(\"organizations\")\n    .insert({\n      name: name.trim(),\n    })\n    .select()\n    .single();\n\n  if (organizationError) {\n    return { success: false, error: organizationError.message };\n  }\n\n  const { error: userOrganizationError } = await supabase\n    .from(\"user_organizations\")\n    .insert({\n      user_id: user.id,\n      organization_id: organization.id,\n      role: \"owner\",\n    })\n    .select()\n    .single();\n\n  if (userOrganizationError) {\n    return { success: false, error: userOrganizationError.message };\n  }\n\n  return { success: true, data: organization };\n}\n\nexport async function createInviteLink(\n  organizationId: string,\n): Promise<ActionResult<{ token: string; expiresAt: string }>> {\n  const supabase = await createClient();\n\n  //authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  //check membership\n  const { data: userOrg, error: accessError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id, role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (accessError || !userOrg) {\n    return {\n      success: false,\n      error: \"User does not have access to this organization!\",\n    };\n  }\n\n  //generate a secure token\n\n  const token = crypto.randomUUID();\n\n  //calculate expiry date\n  const expiresAt = new Date();\n  expiresAt.setDate(expiresAt.getDate() + 7);\n\n  //store the invite in supa\n\n  const { error: inviteError } = await supabase\n    .from(\"organization_invites\")\n    .insert({\n      organization_id: organizationId,\n      created_by: user.id,\n      token,\n      expires_at: expiresAt.toISOString(),\n    });\n\n  if (inviteError) {\n    console.error(\"Failed to create invite:\", inviteError);\n    return { success: false, error: \"Failed to create invite link\" };\n  }\n\n  return {\n    success: true,\n    data: {\n      token,\n      expiresAt: expiresAt.toISOString(),\n    },\n  };\n}\n\nexport async function acceptInvite(\n  token: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return {\n      success: false,\n      error: \"You must be logged in to accept an invite\",\n    };\n  }\n\n  // 2. Fetch and validate invite (with locking to prevent race conditions)\n  const { data: invite, error: inviteError } = await supabase\n    .from(\"organization_invites\")\n    .select(\"*\")\n    .eq(\"token\", token)\n    .is(\"used_at\", null) // Only get unused invites\n    .single();\n\n  if (inviteError || !invite) {\n    return { success: false, error: \"Invalid or expired invite link\" };\n  }\n\n  // 3. Check expiration\n  const now = new Date();\n  const expiresAt = new Date(invite.expires_at);\n  if (now > expiresAt) {\n    return { success: false, error: \"This invite has expired\" };\n  }\n\n  // 4. Check if user is already a member\n  const { data: existingMembership } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id\")\n    .eq(\"organization_id\", invite.organization_id)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (existingMembership) {\n    return {\n      success: false,\n      error: \"You are already a member of this organization\",\n    };\n  }\n\n  // 5. Add user to organization\n  const { error: membershipError } = await supabase\n    .from(\"user_organizations\")\n    .insert({\n      user_id: user.id,\n      organization_id: invite.organization_id,\n      role: \"teammate\", // Default role for invited users\n    });\n\n  if (membershipError) {\n    console.error(\"Failed to add user to organization:\", membershipError);\n    return { success: false, error: \"Failed to join organization\" };\n  }\n\n  // 6. Mark invite as used (using admin client with secret key to bypass RLS)\n  const adminClient = createAdminClient();\n  const { error: updateError } = await adminClient\n    .from(\"organization_invites\")\n    .update({\n      used_at: new Date().toISOString(),\n      used_by: user.id,\n    })\n    .eq(\"token\", token);\n\n  if (updateError) {\n    console.error(\"Failed to mark invite as used:\", updateError);\n    // Don't return error - user was already added successfully\n  }\n\n  return {\n    success: true,\n    data: { organizationId: invite.organization_id },\n  };\n}\n\nexport async function removeMemberFromOrg(\n  organizationId: string,\n  userIdToRemove: string,\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify current user is an owner (RLS will also enforce this)\n  const { data: currentUserRole, error: roleError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (roleError || !currentUserRole || currentUserRole.role !== \"owner\") {\n    return {\n      success: false,\n      error: \"Only organization owners can remove members\",\n    };\n  }\n\n  // 3. Check if the user being removed is the last owner\n  if (userIdToRemove === user.id) {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot remove the last owner from the organization\",\n      };\n    }\n  }\n\n  // 4. Remove the member (RLS policy will enforce owner permission)\n  const { error: deleteError } = await supabase\n    .from(\"user_organizations\")\n    .delete()\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToRemove);\n\n  if (deleteError) {\n    return { success: false, error: \"Failed to remove member\" };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function leaveOrganization(\n  organizationId: string,\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify user is a member of this organization\n  const { data: membership, error: membershipError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (membershipError || !membership) {\n    return {\n      success: false,\n      error: \"You are not a member of this organization\",\n    };\n  }\n\n  // 3. If user is an owner, check if they're the last owner\n  if (membership.role === \"owner\") {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot leave as the last owner. Transfer ownership first.\",\n      };\n    }\n  }\n\n  // 4. Remove the user from the organization\n  const { error: deleteError } = await supabase\n    .from(\"user_organizations\")\n    .delete()\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id);\n\n  if (deleteError) {\n    return { success: false, error: \"Failed to leave organization\" };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function updateMemberRole(\n  organizationId: string,\n  userIdToUpdate: string,\n  newRole: \"owner\" | \"teammate\",\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify current user is an owner\n  const { data: currentUserRole, error: roleError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (roleError || !currentUserRole || currentUserRole.role !== \"owner\") {\n    return {\n      success: false,\n      error: \"Only organization owners can change member roles\",\n    };\n  }\n\n  // 3. Get current role of user being updated\n  const { data: targetUser, error: targetError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToUpdate)\n    .single();\n\n  if (targetError || !targetUser) {\n    return { success: false, error: \"Member not found\" };\n  }\n\n  // 4. If demoting from owner to teammate, check if they're the last owner\n  if (targetUser.role === \"owner\" && newRole === \"teammate\") {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot demote the last owner. Promote another member first.\",\n      };\n    }\n  }\n\n  // 5. Update the role\n  const { error: updateError } = await supabase\n    .from(\"user_organizations\")\n    .update({ role: newRole })\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToUpdate);\n\n  if (updateError) {\n    return { success: false, error: \"Failed to update member role\" };\n  }\n\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAiFsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA4FsB,2BAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/hooks/usePrefetchRoute.ts"],"sourcesContent":["\"use client\";\n\nimport { useRouter } from \"next/navigation\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { getOrgMembers } from \"@/lib/services/orgService\";\nimport { getReposByOrganizationId } from \"@/lib/services/repoService\";\n\n/**\n * Custom hook for prefetching routes and their associated data\n * Combines Next.js route prefetching with React Query data prefetching\n */\nexport function usePrefetchRoute() {\n  const router = useRouter();\n  const queryClient = useQueryClient();\n\n  /**\n   * Prefetch organization page (route + repos data)\n   */\n  const prefetchOrgPage = (orgId: string) => {\n    // Prefetch the route bundle\n    router.prefetch(`/dashboard/org/${orgId}`);\n\n    // Prefetch repositories data\n    queryClient.prefetchQuery({\n      queryKey: [\"repositories\", orgId],\n      queryFn: async () => {\n        const result = await getReposByOrganizationId(orgId);\n        if (!result.success) {\n          throw new Error(result.error);\n        }\n        return result.data;\n      },\n      staleTime: 2 * 60 * 1000, // 2 minutes\n    });\n  };\n\n  /**\n   * Prefetch team page (route + members data)\n   */\n  const prefetchTeamPage = (orgId: string) => {\n    // Prefetch the route bundle\n    router.prefetch(`/dashboard/org/${orgId}/team`);\n\n    // Prefetch members data\n    queryClient.prefetchQuery({\n      queryKey: [\"members\", orgId],\n      queryFn: async () => {\n        const result = await getOrgMembers(orgId);\n        if (!result.success) {\n          throw new Error(result.error);\n        }\n        return result.data;\n      },\n      staleTime: 2 * 60 * 1000, // 2 minutes\n    });\n  };\n\n  /**\n   * Prefetch organizations list page (route + orgs data)\n   */\n  const prefetchOrganizationsPage = () => {\n    router.prefetch(\"/dashboard/organizations\");\n    // Orgs data is already prefetched by the page, so we just prefetch the route\n  };\n\n  /**\n   * Prefetch repository page (route only)\n   */\n  const prefetchRepoPage = (repoId: string) => {\n    // Prefetch the route bundle\n    router.prefetch(`/dashboard/repo/${repoId}`);\n    // TODO: Add data prefetching when repo page services are implemented\n  };\n\n  return {\n    prefetchOrgPage,\n    prefetchTeamPage,\n    prefetchOrganizationsPage,\n    prefetchRepoPage,\n  };\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AACA;;AALA;;;;;AAWO,SAAS;;IACd,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,cAAc,IAAA,2MAAc;IAElC;;GAEC,GACD,MAAM,kBAAkB,CAAC;QACvB,4BAA4B;QAC5B,OAAO,QAAQ,CAAC,CAAC,eAAe,EAAE,OAAO;QAEzC,6BAA6B;QAC7B,YAAY,aAAa,CAAC;YACxB,UAAU;gBAAC;gBAAgB;aAAM;YACjC,SAAS;gBACP,MAAM,SAAS,MAAM,IAAA,6LAAwB,EAAC;gBAC9C,IAAI,CAAC,OAAO,OAAO,EAAE;oBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;gBAC9B;gBACA,OAAO,OAAO,IAAI;YACpB;YACA,WAAW,IAAI,KAAK;QACtB;IACF;IAEA;;GAEC,GACD,MAAM,mBAAmB,CAAC;QACxB,4BAA4B;QAC5B,OAAO,QAAQ,CAAC,CAAC,eAAe,EAAE,MAAM,KAAK,CAAC;QAE9C,wBAAwB;QACxB,YAAY,aAAa,CAAC;YACxB,UAAU;gBAAC;gBAAW;aAAM;YAC5B,SAAS;gBACP,MAAM,SAAS,MAAM,IAAA,kLAAa,EAAC;gBACnC,IAAI,CAAC,OAAO,OAAO,EAAE;oBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;gBAC9B;gBACA,OAAO,OAAO,IAAI;YACpB;YACA,WAAW,IAAI,KAAK;QACtB;IACF;IAEA;;GAEC,GACD,MAAM,4BAA4B;QAChC,OAAO,QAAQ,CAAC;IAChB,6EAA6E;IAC/E;IAEA;;GAEC,GACD,MAAM,mBAAmB,CAAC;QACxB,4BAA4B;QAC5B,OAAO,QAAQ,CAAC,CAAC,gBAAgB,EAAE,QAAQ;IAC3C,qEAAqE;IACvE;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GArEgB;;QACC,kJAAS;QACJ,2MAAc"}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/organizations/card.tsx"],"sourcesContent":["\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Building2, ChevronRight } from \"lucide-react\";\nimport { OrganizationWithRole } from \"@/app/types/supabase\";\nimport { useRouter } from \"next/navigation\";\nimport { usePrefetchRoute } from \"@/hooks/usePrefetchRoute\";\nimport { motion } from \"framer-motion\";\n\ntype OrganizationButtonProps = {\n  organization: OrganizationWithRole;\n};\n\nexport function OrganizationButton({ organization }: OrganizationButtonProps) {\n  const role = organization.role || \"member\";\n  const router = useRouter();\n  const { prefetchOrgPage } = usePrefetchRoute();\n\n  return (\n    <motion.div whileHover=\"hover\" className=\"parent\">\n      <Button\n        variant=\"outline\"\n        className=\"bg-background h-auto min-h-21 justify-start p-4 w-full hover:bg-elevated\"\n        onClick={() => router.push(`/dashboard/org/${organization.id}`)}\n        onMouseEnter={() => prefetchOrgPage(organization.id)}\n      >\n        <div className=\"flex flex-row gap-4 text-sm w-full overflow-hidden\">\n          {/* Surround in a circular container */}\n          <div className=\"rounded-full dark:bg-black border-2 border-primary p-2.5 shrink-0\">\n            <Building2 className=\"text-primary-foreground\" />\n          </div>\n          <div className=\"flex flex-col justify-start items-start min-w-0 flex-1\">\n            <span className=\"font-semibold truncate\">{organization.name}</span>\n            <span className=\"text-muted-foreground text-xs whitespace-nowrap\">\n              {role ? \"Owner\" : \"Member\"}{\" \"}\n              <span className=\"text-md\">&middot;</span> 1 project\n            </span>\n          </div>\n          <motion.div\n            initial={{ opacity: 0.5 }}\n            variants={{ hover: { x: 4, opacity: 1 } }}\n          >\n            <ChevronRight className=\"text-primary-foreground\" />\n          </motion.div>\n        </div>\n      </Button>\n    </motion.div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AAEA;AACA;AACA;;;AAPA;;;;;;AAaO,SAAS,mBAAmB,EAAE,YAAY,EAA2B;;IAC1E,MAAM,OAAO,aAAa,IAAI,IAAI;IAClC,MAAM,SAAS,IAAA,kJAAS;IACxB,MAAM,EAAE,eAAe,EAAE,GAAG,IAAA,uJAAgB;IAE5C,qBACE,6LAAC,uMAAM,CAAC,GAAG;QAAC,YAAW;QAAQ,WAAU;kBACvC,cAAA,6LAAC,+IAAM;YACL,SAAQ;YACR,WAAU;YACV,SAAS,IAAM,OAAO,IAAI,CAAC,CAAC,eAAe,EAAE,aAAa,EAAE,EAAE;YAC9D,cAAc,IAAM,gBAAgB,aAAa,EAAE;sBAEnD,cAAA,6LAAC;gBAAI,WAAU;;kCAEb,6LAAC;wBAAI,WAAU;kCACb,cAAA,6LAAC,gOAAS;4BAAC,WAAU;;;;;;;;;;;kCAEvB,6LAAC;wBAAI,WAAU;;0CACb,6LAAC;gCAAK,WAAU;0CAA0B,aAAa,IAAI;;;;;;0CAC3D,6LAAC;gCAAK,WAAU;;oCACb,uCAAO,UAAU;oCAAU;kDAC5B,6LAAC;wCAAK,WAAU;kDAAU;;;;;;oCAAe;;;;;;;;;;;;;kCAG7C,6LAAC,uMAAM,CAAC,GAAG;wBACT,SAAS;4BAAE,SAAS;wBAAI;wBACxB,UAAU;4BAAE,OAAO;gCAAE,GAAG;gCAAG,SAAS;4BAAE;wBAAE;kCAExC,cAAA,6LAAC,yOAAY;4BAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMpC;GAnCgB;;QAEC,kJAAS;QACI,uJAAgB;;;KAH9B"}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/orgService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient, createAdminClient } from \"@/utils/supabase/server\";\nimport {\n  Organization,\n  OrganizationWithRole,\n  OrganizationMember,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\n\nexport async function getOrgs(): Promise<ActionResult<OrganizationWithRole[]>> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  // Query from user_organizations table to properly filter by user_id\n  const { data: userOrgs, error: organizationsError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role,joined_at,organizations(id,name,created_at)\")\n    .eq(\"user_id\", user.id);\n\n  if (organizationsError) {\n    return { success: false, error: organizationsError.message };\n  }\n\n  // Transform the data to match OrganizationWithRole structure\n  const organizations: OrganizationWithRole[] = (userOrgs ?? []).map((uo) => {\n    const org = uo.organizations as Organization | Organization[];\n    // Handle case where organizations might be an array (shouldn't happen with proper FK)\n    const orgData = Array.isArray(org) ? org[0] : org;\n\n    return {\n      id: orgData.id,\n      name: orgData.name,\n      created_at: orgData.created_at,\n      role: uo.role,\n      joined_at: uo.joined_at,\n    };\n  });\n\n  return {\n    success: true,\n    data: organizations,\n  };\n}\n\nexport async function getOrgById(\n  orgId: string,\n): Promise<ActionResult<Organization>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  const { data: organization, error } = await supabase\n    .from(\"organizations\")\n    .select(\"id,name,created_at\")\n    .eq(\"id\", orgId)\n    .single();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  if (!organization) {\n    return { success: false, error: \"Organization not found\" };\n  }\n\n  return { success: true, data: organization };\n}\n\nexport async function getOrgMembers(\n  orgId: string,\n): Promise<ActionResult<OrganizationMember[]>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // Verify user has access to this organization\n  const { data: userOrg, error: accessError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id\")\n    .eq(\"organization_id\", orgId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (accessError || !userOrg) {\n    return { success: false, error: \"Access denied to this organization\" };\n  }\n\n  // Fetch all members of the organization with their user details\n  // Join with users table to get email addresses\n  const { data: members, error: membersError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"user_id, organization_id, role, joined_at, users(email)\")\n    .eq(\"organization_id\", orgId)\n    .order(\"joined_at\", { ascending: true });\n\n  if (membersError) {\n    return { success: false, error: membersError.message };\n  }\n\n  if (!members || members.length === 0) {\n    return { success: true, data: [] };\n  }\n\n  // Transform the joined data to match OrganizationMember type\n  const membersWithEmails: OrganizationMember[] = members.map((m) => {\n    // Handle the users field which could be an object or array due to the join\n    const userData = m.users as { email: string } | { email: string }[] | null;\n    const email = Array.isArray(userData)\n      ? userData[0]?.email || \"Unknown\"\n      : userData?.email || \"Unknown\";\n\n    return {\n      user_id: m.user_id,\n      organization_id: m.organization_id,\n      role: m.role as \"owner\" | \"teammate\",\n      joined_at: m.joined_at,\n      user_email: email,\n    };\n  });\n\n  return { success: true, data: membersWithEmails };\n}\n\nexport async function createOrg(\n  formData: FormData,\n): Promise<ActionResult<Organization>> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not found\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Organization name is required\" };\n  }\n\n  const { data: organization, error: organizationError } = await supabase\n    .from(\"organizations\")\n    .insert({\n      name: name.trim(),\n    })\n    .select()\n    .single();\n\n  if (organizationError) {\n    return { success: false, error: organizationError.message };\n  }\n\n  const { error: userOrganizationError } = await supabase\n    .from(\"user_organizations\")\n    .insert({\n      user_id: user.id,\n      organization_id: organization.id,\n      role: \"owner\",\n    })\n    .select()\n    .single();\n\n  if (userOrganizationError) {\n    return { success: false, error: userOrganizationError.message };\n  }\n\n  return { success: true, data: organization };\n}\n\nexport async function createInviteLink(\n  organizationId: string,\n): Promise<ActionResult<{ token: string; expiresAt: string }>> {\n  const supabase = await createClient();\n\n  //authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  //check membership\n  const { data: userOrg, error: accessError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id, role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (accessError || !userOrg) {\n    return {\n      success: false,\n      error: \"User does not have access to this organization!\",\n    };\n  }\n\n  //generate a secure token\n\n  const token = crypto.randomUUID();\n\n  //calculate expiry date\n  const expiresAt = new Date();\n  expiresAt.setDate(expiresAt.getDate() + 7);\n\n  //store the invite in supa\n\n  const { error: inviteError } = await supabase\n    .from(\"organization_invites\")\n    .insert({\n      organization_id: organizationId,\n      created_by: user.id,\n      token,\n      expires_at: expiresAt.toISOString(),\n    });\n\n  if (inviteError) {\n    console.error(\"Failed to create invite:\", inviteError);\n    return { success: false, error: \"Failed to create invite link\" };\n  }\n\n  return {\n    success: true,\n    data: {\n      token,\n      expiresAt: expiresAt.toISOString(),\n    },\n  };\n}\n\nexport async function acceptInvite(\n  token: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return {\n      success: false,\n      error: \"You must be logged in to accept an invite\",\n    };\n  }\n\n  // 2. Fetch and validate invite (with locking to prevent race conditions)\n  const { data: invite, error: inviteError } = await supabase\n    .from(\"organization_invites\")\n    .select(\"*\")\n    .eq(\"token\", token)\n    .is(\"used_at\", null) // Only get unused invites\n    .single();\n\n  if (inviteError || !invite) {\n    return { success: false, error: \"Invalid or expired invite link\" };\n  }\n\n  // 3. Check expiration\n  const now = new Date();\n  const expiresAt = new Date(invite.expires_at);\n  if (now > expiresAt) {\n    return { success: false, error: \"This invite has expired\" };\n  }\n\n  // 4. Check if user is already a member\n  const { data: existingMembership } = await supabase\n    .from(\"user_organizations\")\n    .select(\"organization_id\")\n    .eq(\"organization_id\", invite.organization_id)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (existingMembership) {\n    return {\n      success: false,\n      error: \"You are already a member of this organization\",\n    };\n  }\n\n  // 5. Add user to organization\n  const { error: membershipError } = await supabase\n    .from(\"user_organizations\")\n    .insert({\n      user_id: user.id,\n      organization_id: invite.organization_id,\n      role: \"teammate\", // Default role for invited users\n    });\n\n  if (membershipError) {\n    console.error(\"Failed to add user to organization:\", membershipError);\n    return { success: false, error: \"Failed to join organization\" };\n  }\n\n  // 6. Mark invite as used (using admin client with secret key to bypass RLS)\n  const adminClient = createAdminClient();\n  const { error: updateError } = await adminClient\n    .from(\"organization_invites\")\n    .update({\n      used_at: new Date().toISOString(),\n      used_by: user.id,\n    })\n    .eq(\"token\", token);\n\n  if (updateError) {\n    console.error(\"Failed to mark invite as used:\", updateError);\n    // Don't return error - user was already added successfully\n  }\n\n  return {\n    success: true,\n    data: { organizationId: invite.organization_id },\n  };\n}\n\nexport async function removeMemberFromOrg(\n  organizationId: string,\n  userIdToRemove: string,\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify current user is an owner (RLS will also enforce this)\n  const { data: currentUserRole, error: roleError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (roleError || !currentUserRole || currentUserRole.role !== \"owner\") {\n    return {\n      success: false,\n      error: \"Only organization owners can remove members\",\n    };\n  }\n\n  // 3. Check if the user being removed is the last owner\n  if (userIdToRemove === user.id) {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot remove the last owner from the organization\",\n      };\n    }\n  }\n\n  // 4. Remove the member (RLS policy will enforce owner permission)\n  const { error: deleteError } = await supabase\n    .from(\"user_organizations\")\n    .delete()\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToRemove);\n\n  if (deleteError) {\n    return { success: false, error: \"Failed to remove member\" };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function leaveOrganization(\n  organizationId: string,\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify user is a member of this organization\n  const { data: membership, error: membershipError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (membershipError || !membership) {\n    return {\n      success: false,\n      error: \"You are not a member of this organization\",\n    };\n  }\n\n  // 3. If user is an owner, check if they're the last owner\n  if (membership.role === \"owner\") {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot leave as the last owner. Transfer ownership first.\",\n      };\n    }\n  }\n\n  // 4. Remove the user from the organization\n  const { error: deleteError } = await supabase\n    .from(\"user_organizations\")\n    .delete()\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id);\n\n  if (deleteError) {\n    return { success: false, error: \"Failed to leave organization\" };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function updateMemberRole(\n  organizationId: string,\n  userIdToUpdate: string,\n  newRole: \"owner\" | \"teammate\",\n): Promise<ActionResult<void>> {\n  const supabase = await createClient();\n\n  // 1. Authenticate user\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated\" };\n  }\n\n  // 2. Verify current user is an owner\n  const { data: currentUserRole, error: roleError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (roleError || !currentUserRole || currentUserRole.role !== \"owner\") {\n    return {\n      success: false,\n      error: \"Only organization owners can change member roles\",\n    };\n  }\n\n  // 3. Get current role of user being updated\n  const { data: targetUser, error: targetError } = await supabase\n    .from(\"user_organizations\")\n    .select(\"role\")\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToUpdate)\n    .single();\n\n  if (targetError || !targetUser) {\n    return { success: false, error: \"Member not found\" };\n  }\n\n  // 4. If demoting from owner to teammate, check if they're the last owner\n  if (targetUser.role === \"owner\" && newRole === \"teammate\") {\n    const { data: owners, error: ownersError } = await supabase\n      .from(\"user_organizations\")\n      .select(\"user_id\")\n      .eq(\"organization_id\", organizationId)\n      .eq(\"role\", \"owner\");\n\n    if (ownersError) {\n      return { success: false, error: \"Failed to verify ownership status\" };\n    }\n\n    if (owners && owners.length <= 1) {\n      return {\n        success: false,\n        error: \"Cannot demote the last owner. Promote another member first.\",\n      };\n    }\n  }\n\n  // 5. Update the role\n  const { error: updateError } = await supabase\n    .from(\"user_organizations\")\n    .update({ role: newRole })\n    .eq(\"organization_id\", organizationId)\n    .eq(\"user_id\", userIdToUpdate);\n\n  if (updateError) {\n    return { success: false, error: \"Failed to update member role\" };\n  }\n\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAUsB,UAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/ui/empty.tsx"],"sourcesContent":["// components/ui/empty.tsx\r\nimport { ReactNode } from \"react\";\r\n\r\ninterface EmptyProps {\r\n  title: string;\r\n  description?: string;\r\n  children?: ReactNode;\r\n  icon?: ReactNode;\r\n}\r\n\r\nexport function Empty({ title, description, children, icon }: EmptyProps) {\r\n  return (\r\n    <div className=\"flex flex-col items-center justify-center text-center py-12\">\r\n      {icon && <div className=\"mb-3 rounded-lg bg-muted p-2\">{icon}</div>}\r\n      <h3 className=\"text-lg font-semibold\">{title}</h3>\r\n      {description && (\r\n        <p className=\"text-sm text-muted-foreground mt-2\">{description}</p>\r\n      )}\r\n      {children && <div className=\"mt-4\">{children}</div>}\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;;;AAUnB,SAAS,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,EAAc;IACtE,qBACE,6LAAC;QAAI,WAAU;;YACZ,sBAAQ,6LAAC;gBAAI,WAAU;0BAAgC;;;;;;0BACxD,6LAAC;gBAAG,WAAU;0BAAyB;;;;;;YACtC,6BACC,6LAAC;gBAAE,WAAU;0BAAsC;;;;;;YAEpD,0BAAY,6LAAC;gBAAI,WAAU;0BAAQ;;;;;;;;;;;;AAG1C;KAXgB"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/organizations/list.tsx"],"sourcesContent":["\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { OrganizationWithRole } from \"@/app/types/supabase\";\nimport { OrganizationButton } from \"./card\";\nimport { getOrgs } from \"@/lib/services/orgService\";\nimport { Empty } from \"@/components/ui/empty\";\nimport { Button } from \"@/components/ui/button\";\nimport Link from \"next/link\";\nimport { Users, Plus } from \"lucide-react\";\n\nexport function OrganizationList() {\n  const { data, isLoading, error } = useQuery<OrganizationWithRole[]>({\n    queryKey: [\"organizations\"],\n    queryFn: async () => {\n      const result = await getOrgs();\n\n      if (!result.success) {\n        throw new Error(result.error);\n      }\n\n      return result.data as OrganizationWithRole[];\n    },\n  });\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  if (error) {\n    return <div className=\"text-destructive\">Error: {error.message}</div>;\n  }\n\n  if (!data || data.length === 0) {\n    return (\n      <div className=\"flex flex-col justify-center items-center\">\n        <Empty\n          title=\"You Have No Organizations\"\n          description=\"Create or join an organization to get started\"\n          icon={<Users className=\"w-6 h-6 text-muted-foreground\" />}\n        >\n          <Button variant=\"default\" size=\"sm\">\n            <Link href={`/dashboard/new`}>\n              <div className=\"flex items-center gap-1\">\n                <Plus />\n                <span>New organization</span>\n              </div>\n            </Link>\n          </Button>\n        </Empty>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6\">\n      {data.map((organization) => (\n        <OrganizationButton key={organization.id} organization={organization} />\n      ))}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AATA;;;;;;;;AAWO,SAAS;;IACd,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,IAAA,0LAAQ,EAAyB;QAClE,UAAU;YAAC;SAAgB;QAC3B,OAAO;yCAAE;gBACP,MAAM,SAAS,MAAM,IAAA,4KAAO;gBAE5B,IAAI,CAAC,OAAO,OAAO,EAAE;oBACnB,MAAM,IAAI,MAAM,OAAO,KAAK;gBAC9B;gBAEA,OAAO,OAAO,IAAI;YACpB;;IACF;IAEA,IAAI,WAAW;QACb,qBAAO,6LAAC;sBAAI;;;;;;IACd;IAEA,IAAI,OAAO;QACT,qBAAO,6LAAC;YAAI,WAAU;;gBAAmB;gBAAQ,MAAM,OAAO;;;;;;;IAChE;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;QAC9B,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC,6IAAK;gBACJ,OAAM;gBACN,aAAY;gBACZ,oBAAM,6LAAC,gNAAK;oBAAC,WAAU;;;;;;0BAEvB,cAAA,6LAAC,+IAAM;oBAAC,SAAQ;oBAAU,MAAK;8BAC7B,cAAA,6LAAC,0KAAI;wBAAC,MAAM,CAAC,cAAc,CAAC;kCAC1B,cAAA,6LAAC;4BAAI,WAAU;;8CACb,6LAAC,6MAAI;;;;;8CACL,6LAAC;8CAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAOpB;IAEA,qBACE,6LAAC;QAAI,WAAU;kBACZ,KAAK,GAAG,CAAC,CAAC,6BACT,6LAAC,iLAAkB;gBAAuB,cAAc;eAA/B,aAAa,EAAE;;;;;;;;;;AAIhD;GAlDgB;;QACqB,0LAAQ;;;KAD7B"}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/navbar-context-setter.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useNavBarStore } from \"@/lib/stores/useNavbarStore\";\n\ninterface NavbarContextSetterProps {\n  contextText?: string;\n  breadcrumbs?: Array<{ label: string; href?: string }>;\n  appendBreadcrumb?: { label: string; href?: string };\n}\n\n/**\n * Client component that sets the navbar context.\n * Use this in Server Components to update the navbar state.\n *\n * @param contextText - Simple text to display (no breadcrumbs)\n * @param breadcrumbs - Complete breadcrumb trail (replaces existing)\n * @param appendBreadcrumb - Single breadcrumb to append to existing trail\n */\nexport function NavbarContextSetter({\n  contextText,\n  breadcrumbs,\n  appendBreadcrumb,\n}: NavbarContextSetterProps) {\n  const setContext = useNavBarStore((state) => state.setContext);\n  const setBreadcrumbs = useNavBarStore((state) => state.setBreadcrumbs);\n  const appendBreadcrumbAction = useNavBarStore(\n    (state) => state.appendBreadcrumb,\n  );\n  const reset = useNavBarStore((state) => state.reset);\n\n  useEffect(() => {\n    if (breadcrumbs) {\n      setBreadcrumbs(breadcrumbs);\n    } else if (appendBreadcrumb) {\n      appendBreadcrumbAction(appendBreadcrumb);\n    } else if (contextText) {\n      setContext(contextText);\n    }\n\n    // Clean up on unmount\n    return () => {\n      reset();\n    };\n  }, [\n    contextText,\n    breadcrumbs,\n    appendBreadcrumb,\n    setContext,\n    setBreadcrumbs,\n    appendBreadcrumbAction,\n    reset,\n  ]);\n\n  // This component doesn't render anything\n  return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;;AAHA;;;AAmBO,SAAS,oBAAoB,EAClC,WAAW,EACX,WAAW,EACX,gBAAgB,EACS;;IACzB,MAAM,aAAa,IAAA,2JAAc;0DAAC,CAAC,QAAU,MAAM,UAAU;;IAC7D,MAAM,iBAAiB,IAAA,2JAAc;8DAAC,CAAC,QAAU,MAAM,cAAc;;IACrE,MAAM,yBAAyB,IAAA,2JAAc;sEAC3C,CAAC,QAAU,MAAM,gBAAgB;;IAEnC,MAAM,QAAQ,IAAA,2JAAc;qDAAC,CAAC,QAAU,MAAM,KAAK;;IAEnD,IAAA,0KAAS;yCAAC;YACR,IAAI,aAAa;gBACf,eAAe;YACjB,OAAO,IAAI,kBAAkB;gBAC3B,uBAAuB;YACzB,OAAO,IAAI,aAAa;gBACtB,WAAW;YACb;YAEA,sBAAsB;YACtB;iDAAO;oBACL;gBACF;;QACF;wCAAG;QACD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,yCAAyC;IACzC,OAAO;AACT;GArCgB;;QAKK,2JAAc;QACV,2JAAc;QACN,2JAAc;QAG/B,2JAAc;;;KAVd"}},
    {"offset": {"line": 564, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/node_modules/%40tanstack/query-core/src/hydration.ts"],"sourcesContent":["import { tryResolveSync } from './thenable'\nimport { noop } from './utils'\nimport type {\n  DefaultError,\n  MutationKey,\n  MutationMeta,\n  MutationOptions,\n  MutationScope,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\ntype TransformerFn = (data: any) => any\nfunction defaultTransformerFn(data: any): any {\n  return data\n}\n\nexport interface DehydrateOptions {\n  serializeData?: TransformerFn\n  shouldDehydrateMutation?: (mutation: Mutation) => boolean\n  shouldDehydrateQuery?: (query: Query) => boolean\n  shouldRedactErrors?: (error: unknown) => boolean\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    deserializeData?: TransformerFn\n    queries?: QueryOptions\n    mutations?: MutationOptions<unknown, DefaultError, unknown, unknown>\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n  promise?: Promise<unknown>\n  meta?: QueryMeta\n  // This is only optional because older versions of Query might have dehydrated\n  // without it which we need to handle for backwards compatibility.\n  // This should be changed to required in the future.\n  dehydratedAt?: number\n}\n\nexport interface DehydratedState {\n  mutations: Array<DehydratedMutation>\n  queries: Array<DehydratedQuery>\n}\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...(mutation.options.scope && { scope: mutation.options.scope }),\n    ...(mutation.meta && { meta: mutation.meta }),\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(\n  query: Query,\n  serializeData: TransformerFn,\n  shouldRedactErrors: (error: unknown) => boolean,\n): DehydratedQuery {\n  const dehydratePromise = () => {\n    const promise = query.promise?.then(serializeData).catch((error) => {\n      if (!shouldRedactErrors(error)) {\n        // Reject original error if it should not be redacted\n        return Promise.reject(error)\n      }\n      // If not in production, log original error before rejecting redacted error\n      if (process.env.NODE_ENV !== 'production') {\n        console.error(\n          `A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`,\n        )\n      }\n      return Promise.reject(new Error('redacted'))\n    })\n\n    // Avoid unhandled promise rejections\n    // We need the promise we dehydrate to reject to get the correct result into\n    // the query cache, but we also want to avoid unhandled promise rejections\n    // in whatever environment the prefetches are happening in.\n    promise?.catch(noop)\n\n    return promise\n  }\n\n  return {\n    dehydratedAt: Date.now(),\n    state: {\n      ...query.state,\n      ...(query.state.data !== undefined && {\n        data: serializeData(query.state.data),\n      }),\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...(query.state.status === 'pending' && {\n      promise: dehydratePromise(),\n    }),\n    ...(query.meta && { meta: query.meta }),\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nfunction defaultShouldRedactErrors(_: unknown) {\n  return true\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const filterMutation =\n    options.shouldDehydrateMutation ??\n    client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ??\n    defaultShouldDehydrateMutation\n\n  const mutations = client\n    .getMutationCache()\n    .getAll()\n    .flatMap((mutation) =>\n      filterMutation(mutation) ? [dehydrateMutation(mutation)] : [],\n    )\n\n  const filterQuery =\n    options.shouldDehydrateQuery ??\n    client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ??\n    defaultShouldDehydrateQuery\n\n  const shouldRedactErrors =\n    options.shouldRedactErrors ??\n    client.getDefaultOptions().dehydrate?.shouldRedactErrors ??\n    defaultShouldRedactErrors\n\n  const serializeData =\n    options.serializeData ??\n    client.getDefaultOptions().dehydrate?.serializeData ??\n    defaultTransformerFn\n\n  const queries = client\n    .getQueryCache()\n    .getAll()\n    .flatMap((query) =>\n      filterQuery(query)\n        ? [dehydrateQuery(query, serializeData, shouldRedactErrors)]\n        : [],\n    )\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n  const deserializeData =\n    options?.defaultOptions?.deserializeData ??\n    client.getDefaultOptions().hydrate?.deserializeData ??\n    defaultTransformerFn\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(({ state, ...mutationOptions }) => {\n    mutationCache.build(\n      client,\n      {\n        ...client.getDefaultOptions().hydrate?.mutations,\n        ...options?.defaultOptions?.mutations,\n        ...mutationOptions,\n      },\n      state,\n    )\n  })\n\n  queries.forEach(\n    ({ queryKey, state, queryHash, meta, promise, dehydratedAt }) => {\n      const syncData = promise ? tryResolveSync(promise) : undefined\n      const rawData = state.data === undefined ? syncData?.data : state.data\n      const data = rawData === undefined ? rawData : deserializeData(rawData)\n\n      let query = queryCache.get(queryHash)\n      const existingQueryIsPending = query?.state.status === 'pending'\n      const existingQueryIsFetching = query?.state.fetchStatus === 'fetching'\n\n      // Do not hydrate if an existing query exists with newer data\n      if (query) {\n        const hasNewerSyncData =\n          syncData &&\n          // We only need this undefined check to handle older dehydration\n          // payloads that might not have dehydratedAt\n          dehydratedAt !== undefined &&\n          dehydratedAt > query.state.dataUpdatedAt\n        if (\n          state.dataUpdatedAt > query.state.dataUpdatedAt ||\n          hasNewerSyncData\n        ) {\n          // omit fetchStatus from dehydrated state\n          // so that query stays in its current fetchStatus\n          const { fetchStatus: _ignored, ...serializedState } = state\n          query.setState({\n            ...serializedState,\n            data,\n          })\n        }\n      } else {\n        // Restore query\n        query = queryCache.build(\n          client,\n          {\n            ...client.getDefaultOptions().hydrate?.queries,\n            ...options?.defaultOptions?.queries,\n            queryKey,\n            queryHash,\n            meta,\n          },\n          // Reset fetch status to idle to avoid\n          // query being stuck in fetching state upon hydration\n          {\n            ...state,\n            data,\n            fetchStatus: 'idle',\n            status: data !== undefined ? 'success' : state.status,\n          },\n        )\n      }\n\n      if (\n        promise &&\n        !existingQueryIsPending &&\n        !existingQueryIsFetching &&\n        // Only hydrate if dehydration is newer than any existing data,\n        // this is always true for new queries\n        (dehydratedAt === undefined || dehydratedAt > query.state.dataUpdatedAt)\n      ) {\n        // This doesn't actually fetch - it just creates a retryer\n        // which will re-use the passed `initialPromise`\n        // Note that we need to call these even when data was synchronously\n        // available, as we still need to set up the retryer\n        query\n          .fetch(undefined, {\n            // RSC transformed promises are not thenable\n            initialPromise: Promise.resolve(promise).then(deserializeData),\n          })\n          // Avoid unhandled promise rejections\n          .catch(noop)\n      }\n    },\n  )\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAwFU,QAAQ,IAAI,aAAa;AAxFnC,SAAS,sBAAsB;AAC/B,SAAS,YAAY;;;AAiBrB,SAAS,qBAAqB,IAAA,EAAgB;IAC5C,OAAO;AACT;AA2CA,SAAS,kBAAkB,QAAA,EAAwC;IACjE,OAAO;QACL,aAAa,SAAS,OAAA,CAAQ,WAAA;QAC9B,OAAO,SAAS,KAAA;QAChB,GAAI,SAAS,OAAA,CAAQ,KAAA,IAAS;YAAE,OAAO,SAAS,OAAA,CAAQ,KAAA;QAAM,CAAA;QAC9D,GAAI,SAAS,IAAA,IAAQ;YAAE,MAAM,SAAS,IAAA;QAAK,CAAA;IAC7C;AACF;AAMA,SAAS,eACP,KAAA,EACA,aAAA,EACA,kBAAA,EACiB;IACjB,MAAM,mBAAmB,MAAM;QAC7B,MAAM,UAAU,MAAM,OAAA,EAAS,KAAK,aAAa,EAAE,MAAM,CAAC,UAAU;YAClE,IAAI,CAAC,mBAAmB,KAAK,GAAG;gBAE9B,OAAO,QAAQ,MAAA,CAAO,KAAK;YAC7B;YAEA,wCAA2C;gBACzC,QAAQ,KAAA,CACN,CAAA,4DAAA,EAA+D,MAAM,SAAS,CAAA,GAAA,EAAM,KAAK,CAAA,iDAAA,CAAA;YAE7F;YACA,OAAO,QAAQ,MAAA,CAAO,IAAI,MAAM,UAAU,CAAC;QAC7C,CAAC;QAMD,SAAS,MAAM,kLAAI;QAEnB,OAAO;IACT;IAEA,OAAO;QACL,cAAc,KAAK,GAAA,CAAI;QACvB,OAAO;YACL,GAAG,MAAM,KAAA;YACT,GAAI,MAAM,KAAA,CAAM,IAAA,KAAS,KAAA,KAAa;gBACpC,MAAM,cAAc,MAAM,KAAA,CAAM,IAAI;YACtC,CAAA;QACF;QACA,UAAU,MAAM,QAAA;QAChB,WAAW,MAAM,SAAA;QACjB,GAAI,MAAM,KAAA,CAAM,MAAA,KAAW,aAAa;YACtC,SAAS,iBAAiB;QAC5B,CAAA;QACA,GAAI,MAAM,IAAA,IAAQ;YAAE,MAAM,MAAM,IAAA;QAAK,CAAA;IACvC;AACF;AAEO,SAAS,+BAA+B,QAAA,EAAoB;IACjE,OAAO,SAAS,KAAA,CAAM,QAAA;AACxB;AAEO,SAAS,4BAA4B,KAAA,EAAc;IACxD,OAAO,MAAM,KAAA,CAAM,MAAA,KAAW;AAChC;AAEA,SAAS,0BAA0B,CAAA,EAAY;IAC7C,OAAO;AACT;AAEO,SAAS,UACd,MAAA,EACA,UAA4B,CAAC,CAAA,EACZ;IACjB,MAAM,iBACJ,QAAQ,uBAAA,IACR,OAAO,iBAAA,CAAkB,EAAE,SAAA,EAAW,2BACtC;IAEF,MAAM,YAAY,OACf,gBAAA,CAAiB,EACjB,MAAA,CAAO,EACP,OAAA,CAAQ,CAAC,WACR,eAAe,QAAQ,IAAI;YAAC,kBAAkB,QAAQ,CAAC;SAAA,GAAI,CAAC,CAAA;IAGhE,MAAM,cACJ,QAAQ,oBAAA,IACR,OAAO,iBAAA,CAAkB,EAAE,SAAA,EAAW,wBACtC;IAEF,MAAM,qBACJ,QAAQ,kBAAA,IACR,OAAO,iBAAA,CAAkB,EAAE,SAAA,EAAW,sBACtC;IAEF,MAAM,gBACJ,QAAQ,aAAA,IACR,OAAO,iBAAA,CAAkB,EAAE,SAAA,EAAW,iBACtC;IAEF,MAAM,UAAU,OACb,aAAA,CAAc,EACd,MAAA,CAAO,EACP,OAAA,CAAQ,CAAC,QACR,YAAY,KAAK,IACb;YAAC,eAAe,OAAO,eAAe,kBAAkB,CAAC;SAAA,GACzD,CAAC,CAAA;IAGT,OAAO;QAAE;QAAW;IAAQ;AAC9B;AAEO,SAAS,QACd,MAAA,EACA,eAAA,EACA,OAAA,EACM;IACN,IAAI,OAAO,oBAAoB,YAAY,oBAAoB,MAAM;QACnE;IACF;IAEA,MAAM,gBAAgB,OAAO,gBAAA,CAAiB;IAC9C,MAAM,aAAa,OAAO,aAAA,CAAc;IACxC,MAAM,kBACJ,SAAS,gBAAgB,mBACzB,OAAO,iBAAA,CAAkB,EAAE,OAAA,EAAS,mBACpC;IAGF,MAAM,YAAa,gBAAoC,SAAA,IAAa,CAAC,CAAA;IAErE,MAAM,UAAW,gBAAoC,OAAA,IAAW,CAAC,CAAA;IAEjE,UAAU,OAAA,CAAQ,CAAC,EAAE,KAAA,EAAO,GAAG,gBAAgB,CAAA,KAAM;QACnD,cAAc,KAAA,CACZ,QACA;YACE,GAAG,OAAO,iBAAA,CAAkB,EAAE,OAAA,EAAS,SAAA;YACvC,GAAG,SAAS,gBAAgB,SAAA;YAC5B,GAAG,eAAA;QACL,GACA;IAEJ,CAAC;IAED,QAAQ,OAAA,CACN,CAAC,EAAE,QAAA,EAAU,KAAA,EAAO,SAAA,EAAW,IAAA,EAAM,OAAA,EAAS,YAAA,CAAa,CAAA,KAAM;QAC/D,MAAM,WAAW,UAAU,qMAAe,OAAO,IAAI,KAAA;QACrD,MAAM,UAAU,MAAM,IAAA,KAAS,KAAA,IAAY,UAAU,OAAO,MAAM,IAAA;QAClE,MAAM,OAAO,YAAY,KAAA,IAAY,UAAU,gBAAgB,OAAO;QAEtE,IAAI,QAAQ,WAAW,GAAA,CAAI,SAAS;QACpC,MAAM,yBAAyB,OAAO,MAAM,WAAW;QACvD,MAAM,0BAA0B,OAAO,MAAM,gBAAgB;QAG7D,IAAI,OAAO;YACT,MAAM,mBACJ,YAAA,gEAAA;YAAA,4CAAA;YAGA,iBAAiB,KAAA,KACjB,eAAe,MAAM,KAAA,CAAM,aAAA;YAC7B,IACE,MAAM,aAAA,GAAgB,MAAM,KAAA,CAAM,aAAA,IAClC,kBACA;gBAGA,MAAM,EAAE,aAAa,QAAA,EAAU,GAAG,gBAAgB,CAAA,GAAI;gBACtD,MAAM,QAAA,CAAS;oBACb,GAAG,eAAA;oBACH;gBACF,CAAC;YACH;QACF,OAAO;YAEL,QAAQ,WAAW,KAAA,CACjB,QACA;gBACE,GAAG,OAAO,iBAAA,CAAkB,EAAE,OAAA,EAAS,OAAA;gBACvC,GAAG,SAAS,gBAAgB,OAAA;gBAC5B;gBACA;gBACA;YACF,GAAA,sCAAA;YAAA,qDAAA;YAGA;gBACE,GAAG,KAAA;gBACH;gBACA,aAAa;gBACb,QAAQ,SAAS,KAAA,IAAY,YAAY,MAAM,MAAA;YACjD;QAEJ;QAEA,IACE,WACA,CAAC,0BACD,CAAC,2BAAA,+DAAA;QAAA,sCAAA;QAAA,CAGA,iBAAiB,KAAA,KAAa,eAAe,MAAM,KAAA,CAAM,aAAA,GAC1D;YAKA,MACG,KAAA,CAAM,KAAA,GAAW;gBAAA,4CAAA;gBAEhB,gBAAgB,QAAQ,OAAA,CAAQ,OAAO,EAAE,IAAA,CAAK,eAAe;YAC/D,CAAC,EAEA,KAAA,CAAM,kLAAI;QACf;IACF;AAEJ"}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/node_modules/%40tanstack/react-query/src/HydrationBoundary.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state: DehydratedState | null | undefined\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = state.queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          // eslint-disable-next-line react-hooks/refs\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"],"names":[],"mappings":";;;;;AACA,YAAY,WAAW;AAEvB,SAAS,eAAe;AACxB,SAAS,sBAAsB;;;;;AAoBxB,IAAM,oBAAoB,CAAC,EAChC,QAAA,EACA,UAAU,CAAC,CAAA,EACX,KAAA,EACA,WAAA,EACF,KAA8B;IAC5B,MAAM,aAAS,2MAAA,EAAe,WAAW;IAEzC,MAAM,aAAmB,uKAAA,CAAO,OAAO;IACjC,0KAAA;uCAAU,MAAM;YACpB,WAAW,OAAA,GAAU;QACvB,CAAC;;IAiBD,MAAM,iBACE,wKAAA;qDAAQ,MAAM;YAClB,IAAI,OAAO;gBACT,IAAI,OAAO,UAAU,UAAU;oBAC7B;gBACF;gBAEA,MAAM,aAAa,OAAO,aAAA,CAAc;gBAKxC,MAAM,UAAU,MAAM,OAAA,IAAW,CAAC,CAAA;gBAElC,MAAM,aAAyC,CAAC,CAAA;gBAChD,MAAM,kBAA8C,CAAC,CAAA;gBACrD,KAAA,MAAW,mBAAmB,QAAS;oBACrC,MAAM,gBAAgB,WAAW,GAAA,CAAI,gBAAgB,SAAS;oBAE9D,IAAI,CAAC,eAAe;wBAClB,WAAW,IAAA,CAAK,eAAe;oBACjC,OAAO;wBACL,MAAM,mBACJ,gBAAgB,KAAA,CAAM,aAAA,GACpB,cAAc,KAAA,CAAM,aAAA,IACrB,gBAAgB,OAAA,IACf,cAAc,KAAA,CAAM,MAAA,KAAW,aAC/B,cAAc,KAAA,CAAM,WAAA,KAAgB,cACpC,gBAAgB,YAAA,KAAiB,KAAA,KACjC,gBAAgB,YAAA,GACd,cAAc,KAAA,CAAM,aAAA;wBAE1B,IAAI,kBAAkB;4BACpB,gBAAgB,IAAA,CAAK,eAAe;wBACtC;oBACF;gBACF;gBAEA,IAAI,WAAW,MAAA,GAAS,GAAG;oBAIzB,IAAA,yLAAA,EAAQ,QAAQ;wBAAE,SAAS;oBAAW,GAAG,WAAW,OAAO;gBAC7D;gBACA,IAAI,gBAAgB,MAAA,GAAS,GAAG;oBAC9B,OAAO;gBACT;YACF;YACA,OAAO,KAAA;QACT;oDAAG;QAAC;QAAQ,KAAK;KAAC;IAEd,0KAAA;uCAAU,MAAM;YACpB,IAAI,gBAAgB;gBAClB,IAAA,yLAAA,EAAQ,QAAQ;oBAAE,SAAS;gBAAe,GAAG,WAAW,OAAO;YACjE;QACF;sCAAG;QAAC;QAAQ,cAAc;KAAC;IAE3B,OAAO;AACT"}},
    {"offset": {"line": 803, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/plus.js","sources":["file:///home/mann/codecompass/node_modules/lucide-react/src/icons/plus.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M5 12h14', key: '1ays0h' }],\n  ['path', { d: 'M12 5v14', key: 's699le' }],\n];\n\n/**\n * @component @name Plus\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNSAxMmgxNCIgLz4KICA8cGF0aCBkPSJNMTIgNXYxNCIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/plus\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Plus = createLucideIcon('plus', __iconNode);\n\nexport default Plus;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC3C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,IAAA,CAAA,CAAA,KAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,iKAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}}]
}