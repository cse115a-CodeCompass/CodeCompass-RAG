{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/file-tree.tsx"],"sourcesContent":["import { JSX } from \"react\";\nimport { Search, ChevronRight, X } from \"lucide-react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { formatRelativeTime } from \"@/lib/utils\";\n\ninterface Page {\n  id: string;\n  documentation_id: string;\n  title: string;\n  slug: string;\n  content: string;\n  order_index: number;\n  parent_page_id: string | null;\n  referenced_files: string[] | null;\n  referenced_symbols: string[] | null;\n  metadata: JSON | null;\n  created_at: string;\n  updated_at: string;\n  version: number;\n}\n\ninterface FileTreeNode extends Page {\n  children: FileTreeNode[];\n}\n\ninterface FileTreeSidebarProps {\n  fileTree: FileTreeNode[];\n  selectedFile: Page | null;\n  expandedNodes: Set<string>;\n  searchQuery: string;\n  lastIndexed: string;\n  onSelectFile: (file: Page) => void;\n  onToggleExpanded: (nodeId: string) => void;\n  onSearchChange: (query: string) => void;\n  isOpen?: boolean;\n  onClose?: () => void;\n}\n\nexport function FileTreeSidebar({\n  fileTree,\n  selectedFile,\n  expandedNodes,\n  searchQuery,\n  lastIndexed,\n  onSelectFile,\n  onToggleExpanded,\n  onSearchChange,\n  isOpen = false,\n  onClose,\n}: FileTreeSidebarProps) {\n  const filterNodes = (\n    nodes: FileTreeNode[],\n    query: string,\n  ): FileTreeNode[] => {\n    if (!query) return nodes;\n\n    const lowerQuery = query.toLowerCase();\n    const filtered: FileTreeNode[] = [];\n\n    nodes.forEach((node) => {\n      const matchesSearch = node.title.toLowerCase().includes(lowerQuery);\n      const filteredChildren = filterNodes(node.children, query);\n\n      if (matchesSearch || filteredChildren.length > 0) {\n        filtered.push({\n          ...node,\n          children: filteredChildren,\n        });\n      }\n    });\n\n    return filtered;\n  };\n\n  const filteredTree = filterNodes(fileTree, searchQuery);\n\n  const renderFileTree = (\n    nodes: FileTreeNode[],\n    level: number = 0,\n  ): JSX.Element[] => {\n    return nodes.map((node) => {\n      const hasChildren = node.children.length > 0;\n      const isExpanded = searchQuery ? true : expandedNodes.has(node.id);\n      const isSelected = selectedFile?.id === node.id;\n\n      return (\n        <div key={node.id}>\n          <button\n            onClick={() => {\n              handleSelectFile(node);\n              if (hasChildren) {\n                onToggleExpanded(node.id);\n              }\n            }}\n            className={`w-full flex items-center gap-2 px-2 py-1.5 text-sm transition-colors rounded ${\n              isSelected\n                ? \"bg-elevated dark:text-white\"\n                : \"text-gray-400 hover:bg-elevated/50 dark:hover:text-gray-300\"\n            }`}\n            style={{ paddingLeft: `${level * 12 + 8}px` }}\n          >\n            {hasChildren ? (\n              <motion.div\n                animate={{ rotate: isExpanded ? 90 : 0 }}\n                transition={{ duration: 0.2 }}\n              >\n                <ChevronRight className=\"w-3 h-3 shrink-0\" />\n              </motion.div>\n            ) : (\n              <div className=\"w-3\" />\n            )}\n            <span className=\"truncate text-xs\">{node.title}</span>\n          </button>\n          {hasChildren && (\n            <AnimatePresence initial={false}>\n              {isExpanded && (\n                <motion.div\n                  initial={{ height: 0, opacity: 0 }}\n                  animate={{ height: \"auto\", opacity: 1 }}\n                  exit={{ height: 0, opacity: 0 }}\n                  transition={{ duration: 0.3, ease: \"easeInOut\" }}\n                  className=\"overflow-hidden\"\n                >\n                  <div className=\"pt-1\">\n                    {renderFileTree(node.children, level + 1)}\n                  </div>\n                </motion.div>\n              )}\n            </AnimatePresence>\n          )}\n        </div>\n      );\n    });\n  };\n\n  const handleSelectFile = (file: Page) => {\n    onSelectFile(file);\n    // Close mobile drawer after selection\n    if (onClose) {\n      onClose();\n    }\n  };\n\n  return (\n    <>\n      {/* Mobile backdrop */}\n      {isOpen && onClose && (\n        <div\n          className=\"fixed inset-0 bg-black/50 z-40 lg:hidden\"\n          onClick={onClose}\n        />\n      )}\n\n      {/* Sidebar */}\n      <div\n        className={`\n        w-64 border-r border-border flex flex-col bg-background h-full\n        lg:relative lg:translate-x-0\n        ${isOpen ? \"fixed inset-y-0 left-0 z-50 translate-x-0\" : \"hidden lg:flex\"}\n      `}\n      >\n        {/* Mobile close button */}\n        {onClose && (\n          <div className=\"lg:hidden p-3 border-b border-border flex items-center justify-between\">\n            <span className=\"text-sm font-semibold\">Documentation</span>\n            <button onClick={onClose} className=\"p-1 hover:bg-elevated rounded\">\n              <X className=\"w-4 h-4\" />\n            </button>\n          </div>\n        )}\n\n        <div className=\"p-3 border-b border-border\">\n          <div className=\"text-xs text-gray-500 mb-2\">\n            Last indexed: {formatRelativeTime(lastIndexed)}\n          </div>\n        </div>\n\n        <div className=\"p-2 border-b border-border\">\n          <div className=\"relative\">\n            <Search className=\"absolute left-2 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-500\" />\n            <input\n              type=\"text\"\n              value={searchQuery}\n              onChange={(e) => onSearchChange(e.target.value)}\n              placeholder=\"Search...\"\n              className=\"w-full bg-white dark:bg-gray-900 border border-border rounded pl-7 pr-2 py-1 text-xs focus:outline-none focus:ring-1 focus:ring-teal-500\"\n            />\n          </div>\n        </div>\n\n        <div className=\"flex-1 overflow-y-auto p-2\">\n          {filteredTree.length > 0 ? (\n            renderFileTree(filteredTree).map((element, index) => {\n              // Clone element and update onSelectFile handler\n              return <div key={index}>{element}</div>;\n            })\n          ) : (\n            <div className=\"text-xs text-gray-500 p-2\">No results found</div>\n          )}\n        </div>\n      </div>\n    </>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/stores/useDocumentationStore.ts"],"sourcesContent":["import { create } from \"zustand\";\n\ninterface VersionInfo {\n  version: number;\n  createdAt: string;\n  updatedAt: string | null;\n}\n\ninterface DocumentationState {\n  selectedVersion: number | null;\n  availableVersions: VersionInfo[];\n  isLoading: boolean;\n  isIndexing: boolean;\n\n  // Actions\n  selectVersion: (version: number) => void;\n  setAvailableVersions: (versions: VersionInfo[]) => void;\n  setIsLoading: (loading: boolean) => void;\n  setIsIndexing: (indexing: boolean) => void;\n  reset: () => void;\n}\n\nexport const useDocumentationStore = create<DocumentationState>((set) => ({\n  selectedVersion: null,\n  availableVersions: [],\n  isLoading: false,\n  isIndexing: false,\n\n  selectVersion: (version) => set({ selectedVersion: version }),\n  setAvailableVersions: (versions) => set({ availableVersions: versions }),\n  setIsLoading: (loading) => set({ isLoading: loading }),\n  setIsIndexing: (indexing) => set({ isIndexing: indexing }),\n  reset: () =>\n    set({\n      selectedVersion: null,\n      availableVersions: [],\n      isLoading: false,\n      isIndexing: false,\n    }),\n}));\n"],"names":[],"mappings":";;;;AAAA;;AAsBO,MAAM,wBAAwB,IAAA,kJAAM,EAAqB,CAAC,MAAQ,CAAC;QACxE,iBAAiB;QACjB,mBAAmB,EAAE;QACrB,WAAW;QACX,YAAY;QAEZ,eAAe,CAAC,UAAY,IAAI;gBAAE,iBAAiB;YAAQ;QAC3D,sBAAsB,CAAC,WAAa,IAAI;gBAAE,mBAAmB;YAAS;QACtE,cAAc,CAAC,UAAY,IAAI;gBAAE,WAAW;YAAQ;QACpD,eAAe,CAAC,WAAa,IAAI;gBAAE,YAAY;YAAS;QACxD,OAAO,IACL,IAAI;gBACF,iBAAiB;gBACjB,mBAAmB,EAAE;gBACrB,WAAW;gBACX,YAAY;YACd;IACJ,CAAC"}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/version-selector.tsx"],"sourcesContent":["\"use client\";\n\nimport { Check, ChevronDown, History } from \"lucide-react\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { useDocumentationStore } from \"@/lib/stores/useDocumentationStore\";\n\nexport default function VersionSelector() {\n  const selectedVersion = useDocumentationStore(\n    (state) => state.selectedVersion,\n  );\n  const availableVersions = useDocumentationStore(\n    (state) => state.availableVersions,\n  );\n  const selectVersion = useDocumentationStore((state) => state.selectVersion);\n\n  // If no versions available, don't render\n  if (availableVersions.length === 0) {\n    return null;\n  }\n\n  const formatDate = (dateString: string) => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString(\"en-US\", {\n      month: \"short\",\n      day: \"numeric\",\n      year: \"numeric\",\n    });\n  };\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <button className=\"flex items-center gap-2 px-3 py-1.5 bg-card hover:bg-accent/10 border border-border rounded-lg transition-colors text-sm\">\n          <div className=\"flex items-center gap-2\">\n            <History className=\"w-3 h-3 text-muted-foreground\" />\n            <span className=\"text-muted-foreground text-xs\">Version</span>\n            <span className=\"text-foreground font-medium text-xs\">\n              {selectedVersion ?? \"N/A\"}\n            </span>\n          </div>\n          <ChevronDown className=\"w-3 h-3 text-muted-foreground\" />\n        </button>\n      </DropdownMenuTrigger>\n\n      <DropdownMenuContent\n        className=\"bg-card border-border\"\n        align=\"start\"\n        sideOffset={8}\n      >\n        <DropdownMenuLabel className=\"text-xs font-semibold text-muted-foreground\">\n          SELECT VERSION\n        </DropdownMenuLabel>\n\n        <DropdownMenuGroup>\n          {availableVersions.map((version) => (\n            <DropdownMenuItem\n              key={version.version}\n              onClick={() => selectVersion(version.version)}\n              className={`cursor-pointer ${\n                selectedVersion === version.version\n                  ? \"text-foreground focus:text-foreground\"\n                  : \"text-muted-foreground\"\n              }`}\n            >\n              <div className=\"flex items-start justify-between gap-2 w-full\">\n                <div className=\"flex-1 min-w-0\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-sm font-medium\">\n                      Version {version.version}\n                    </span>\n                    {version.version ===\n                      availableVersions[0]?.version && (\n                      <span className=\"text-xs px-1.5 py-0.5 rounded bg-accent text-accent-foreground\">\n                        Latest\n                      </span>\n                    )}\n                  </div>\n                  <div className=\"text-xs text-muted-foreground mt-0.5\">\n                    {formatDate(version.createdAt)}\n                  </div>\n                </div>\n\n                {selectedVersion === version.version && (\n                  <Check className=\"w-4 h-4 shrink-0 text-accent\" />\n                )}\n              </div>\n            </DropdownMenuItem>\n          ))}\n        </DropdownMenuGroup>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AAAA;AACA;AAQA;AAXA;;;;;AAae,SAAS;IACtB,MAAM,kBAAkB,IAAA,sKAAqB,EAC3C,CAAC,QAAU,MAAM,eAAe;IAElC,MAAM,oBAAoB,IAAA,sKAAqB,EAC7C,CAAC,QAAU,MAAM,iBAAiB;IAEpC,MAAM,gBAAgB,IAAA,sKAAqB,EAAC,CAAC,QAAU,MAAM,aAAa;IAE1E,yCAAyC;IACzC,IAAI,kBAAkB,MAAM,KAAK,GAAG;QAClC,OAAO;IACT;IAEA,MAAM,aAAa,CAAC;QAClB,MAAM,OAAO,IAAI,KAAK;QACtB,OAAO,KAAK,kBAAkB,CAAC,SAAS;YACtC,OAAO;YACP,KAAK;YACL,MAAM;QACR;IACF;IAEA,qBACE,8OAAC,4JAAY;;0BACX,8OAAC,mKAAmB;gBAAC,OAAO;0BAC1B,cAAA,8OAAC;oBAAO,WAAU;;sCAChB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,mNAAO;oCAAC,WAAU;;;;;;8CACnB,8OAAC;oCAAK,WAAU;8CAAgC;;;;;;8CAChD,8OAAC;oCAAK,WAAU;8CACb,mBAAmB;;;;;;;;;;;;sCAGxB,8OAAC,mOAAW;4BAAC,WAAU;;;;;;;;;;;;;;;;;0BAI3B,8OAAC,mKAAmB;gBAClB,WAAU;gBACV,OAAM;gBACN,YAAY;;kCAEZ,8OAAC,iKAAiB;wBAAC,WAAU;kCAA8C;;;;;;kCAI3E,8OAAC,iKAAiB;kCACf,kBAAkB,GAAG,CAAC,CAAC,wBACtB,8OAAC,gKAAgB;gCAEf,SAAS,IAAM,cAAc,QAAQ,OAAO;gCAC5C,WAAW,CAAC,eAAe,EACzB,oBAAoB,QAAQ,OAAO,GAC/B,0CACA,yBACJ;0CAEF,cAAA,8OAAC;oCAAI,WAAU;;sDACb,8OAAC;4CAAI,WAAU;;8DACb,8OAAC;oDAAI,WAAU;;sEACb,8OAAC;4DAAK,WAAU;;gEAAsB;gEAC3B,QAAQ,OAAO;;;;;;;wDAEzB,QAAQ,OAAO,KACd,iBAAiB,CAAC,EAAE,EAAE,yBACtB,8OAAC;4DAAK,WAAU;sEAAiE;;;;;;;;;;;;8DAKrF,8OAAC;oDAAI,WAAU;8DACZ,WAAW,QAAQ,SAAS;;;;;;;;;;;;wCAIhC,oBAAoB,QAAQ,OAAO,kBAClC,8OAAC,6MAAK;4CAAC,WAAU;;;;;;;;;;;;+BA3BhB,QAAQ,OAAO;;;;;;;;;;;;;;;;;;;;;;AAoClC"}},
    {"offset": {"line": 576, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Dialog({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Root>) {\n  return <DialogPrimitive.Root data-slot=\"dialog\" {...props} />\n}\n\nfunction DialogTrigger({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {\n  return <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />\n}\n\nfunction DialogPortal({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Portal>) {\n  return <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />\n}\n\nfunction DialogClose({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Close>) {\n  return <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />\n}\n\nfunction DialogOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {\n  return (\n    <DialogPrimitive.Overlay\n      data-slot=\"dialog-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogContent({\n  className,\n  children,\n  showCloseButton = true,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Content> & {\n  showCloseButton?: boolean\n}) {\n  return (\n    <DialogPortal data-slot=\"dialog-portal\">\n      <DialogOverlay />\n      <DialogPrimitive.Content\n        data-slot=\"dialog-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        {showCloseButton && (\n          <DialogPrimitive.Close\n            data-slot=\"dialog-close\"\n            className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\"\n          >\n            <XIcon />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        )}\n      </DialogPrimitive.Content>\n    </DialogPortal>\n  )\n}\n\nfunction DialogHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-header\"\n      className={cn(\"flex flex-col gap-2 text-center sm:text-left\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-footer\"\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Title>) {\n  return (\n    <DialogPrimitive.Title\n      data-slot=\"dialog-title\"\n      className={cn(\"text-lg leading-none font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Description>) {\n  return (\n    <DialogPrimitive.Description\n      data-slot=\"dialog-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,cAAc,EACrB,GAAG,OACkD;IACrD,qBAAO,8OAAC,6KAAuB;QAAC,aAAU;QAAkB,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,aAAa,EACpB,GAAG,OACiD;IACpD,qBAAO,8OAAC,4KAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,GAAG,OACkD;IACrD,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,kBAAkB,IAAI,EACtB,GAAG,OAGJ;IACC,qBACE,8OAAC;QAAa,aAAU;;0BACtB,8OAAC;;;;;0BACD,8OAAC,6KAAuB;gBACtB,aAAU;gBACV,WAAW,IAAA,yHAAE,EACX,+WACA;gBAED,GAAG,KAAK;;oBAER;oBACA,iCACC,8OAAC,2KAAqB;wBACpB,aAAU;wBACV,WAAU;;0CAEV,8OAAC,yMAAK;;;;;0CACN,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAMtC;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,0DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,iLAA2B;QAC1B,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/main-content.tsx"],"sourcesContent":["import { ChevronRight } from \"lucide-react\";\nimport ReactMarkdown from \"react-markdown\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { useTheme } from \"next-themes\";\nimport VersionSelector from \"@/components/dashboard/chat/version-selector\";\nimport mermaid from \"mermaid\";\nimport { motion } from \"framer-motion\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\n\n// Initialize Mermaid once (outside component to avoid re-initialization)\nlet mermaidInitialized = false;\nconst initializeMermaid = (theme: string) => {\n  mermaid.initialize({\n    startOnLoad: false,\n    theme: theme === \"dark\" ? \"dark\" : \"default\",\n    securityLevel: \"loose\",\n    fontFamily: \"ui-sans-serif, system-ui, sans-serif\",\n  });\n  mermaidInitialized = true;\n};\n\ninterface Page {\n  id: string;\n  documentation_id: string;\n  title: string;\n  slug: string;\n  content: string;\n  order_index: number;\n  parent_page_id: string | null;\n  referenced_files: string[] | null;\n  referenced_symbols: string[] | null;\n  metadata: JSON | null;\n  created_at: string;\n  updated_at: string;\n  version: number;\n}\n\ninterface MainContentProps {\n  selectedFile: Page | null;\n  scrollContainerRef?: React.RefObject<HTMLDivElement | null>;\n}\n\ninterface MermaidComponentProps {\n  chart: string;\n}\n\nfunction MermaidComponent({ chart }: MermaidComponentProps) {\n  const ref = useRef<HTMLDivElement>(null);\n  const [error, setError] = useState<string | null>(null);\n  const { theme, resolvedTheme } = useTheme();\n  const [mounted, setMounted] = useState(false);\n\n  // Avoid hydration mismatch by waiting for client-side mount\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  useEffect(() => {\n    if (!mounted || !ref.current) return;\n\n    const currentTheme = resolvedTheme || theme || \"dark\";\n\n    // Re-initialize Mermaid when theme changes\n    if (!mermaidInitialized || ref.current.dataset.theme !== currentTheme) {\n      initializeMermaid(currentTheme);\n    }\n\n    const renderDiagram = async () => {\n      if (!ref.current) return;\n\n      try {\n        // Clear previous content\n        ref.current.innerHTML = \"\";\n        setError(null);\n\n        // Generate unique ID for each diagram\n        const id = `mermaid-${Math.random().toString(36).substr(2, 9)}`;\n\n        // Render the diagram\n        const { svg } = await mermaid.render(id, chart);\n\n        if (ref.current) {\n          ref.current.innerHTML = svg;\n          ref.current.dataset.theme = currentTheme;\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to render diagram\";\n        console.error(\"Mermaid rendering error:\", err);\n        setError(errorMessage);\n      }\n    };\n\n    renderDiagram();\n  }, [chart, theme, resolvedTheme, mounted]);\n\n  if (!mounted) {\n    return (\n      <div className=\"my-6 flex justify-center items-center min-h-[200px] bg-grey-900 rounded border border-grey-800\">\n        <p className=\"text-grey-500 text-sm\">Loading diagram...</p>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"my-6 bg-red-900/20 border border-red-800 rounded p-4\">\n        <p className=\"text-red-400 text-sm font-semibold mb-1\">\n          Diagram rendering failed\n        </p>\n        <p className=\"text-red-300/80 text-xs\">{error}</p>\n        <details className=\"mt-2\">\n          <summary className=\"text-xs text-red-300/60 cursor-pointer hover:text-red-300/80\">\n            View source\n          </summary>\n          <pre className=\"mt-2 text-xs text-red-200/60 overflow-x-auto bg-red-950/30 p-2 rounded\">\n            {chart}\n          </pre>\n        </details>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={ref}\n      className=\"mermaid my-6 flex justify-center items-center overflow-x-auto\"\n    />\n  );\n}\n\nexport function MainContent({\n  selectedFile,\n  scrollContainerRef: externalRef,\n}: MainContentProps) {\n  const internalRef = useRef<HTMLDivElement>(null);\n  const scrollContainerRef = externalRef || internalRef;\n  const [isFilesDialogOpen, setIsFilesDialogOpen] = useState(false);\n\n  useEffect(() => {\n    if (scrollContainerRef.current) {\n      scrollContainerRef.current.scrollTo(0, 0);\n    }\n  }, [selectedFile, scrollContainerRef]);\n\n  if (!selectedFile) {\n    return (\n      <div className=\"flex-1 flex flex-col\">\n        <div className=\"border-b border-grey-800 px-6 py-3\"></div>\n        <div className=\"flex-1 flex items-center justify-center\">\n          <p className=\"text-grey-500 text-sm\">\n            Select a file to view documentation\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  const generateHeadingId = (text: string) => {\n    return text.toLowerCase().replace(/[^\\w]+/g, \"-\");\n  };\n\n  return (\n    <div className=\"flex-1 flex flex-col\">\n      <div className=\"border-b border-grey-800 px-6 py-3 flex items-center justify-between\">\n        <div className=\"flex flex-row gap-5 items-center\">\n          <h1 className=\"text-xl font-bold\">{selectedFile.title}</h1>\n          <VersionSelector />\n        </div>\n        <Dialog open={isFilesDialogOpen} onOpenChange={setIsFilesDialogOpen}>\n          <DialogTrigger asChild>\n            <motion.button\n              className=\"text-xs h-8 px-4 border border-grey-700 rounded hover:bg-grey-800 transition-colors flex items-center gap-2\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ type: \"spring\", stiffness: 400, damping: 17 }}\n            >\n              <span>Relevant source files</span>\n              <motion.div\n                animate={{ x: [0, 3, 0] }}\n                transition={{\n                  repeat: Infinity,\n                  duration: 1.5,\n                  ease: \"easeInOut\",\n                }}\n              >\n                <ChevronRight className=\"w-3 h-3\" />\n              </motion.div>\n            </motion.button>\n          </DialogTrigger>\n\n          <DialogContent className=\"max-w-md\">\n            <DialogHeader>\n              <DialogTitle>Referenced Source Files</DialogTitle>\n              <DialogDescription>\n                {selectedFile.referenced_files &&\n                selectedFile.referenced_files.length > 0\n                  ? `${selectedFile.referenced_files.length} file(s) referenced in this documentation`\n                  : \"No referenced files\"}\n              </DialogDescription>\n            </DialogHeader>\n\n            <div className=\"py-4\">\n              {!selectedFile.referenced_files ||\n              selectedFile.referenced_files.length === 0 ? (\n                <p className=\"text-sm text-grey-400 text-center py-6\">\n                  No source files are referenced in this documentation page.\n                </p>\n              ) : (\n                <div className=\"flex flex-col gap-2\">\n                  {selectedFile.referenced_files.map((file, index) => (\n                    <div\n                      key={index}\n                      className=\"bg-grey-800 hover:bg-grey-700 rounded px-3 py-2 text-xs text-teal-400 transition-colors font-mono break-words\"\n                    >\n                      {file}\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      <div\n        ref={scrollContainerRef}\n        className=\"flex-1 overflow-y-auto bg-grey-950\"\n      >\n        <div className=\"max-w-full lg:max-w-4xl mx-4 md:mx-8 lg:ml-24 lg:mr-8 py-8 pb-135\">\n          <div className=\"markdown-content\">\n            <ReactMarkdown\n              components={{\n                h1: ({ node, children, ...props }) => {\n                  const text = typeof children === \"string\" ? children : \"\";\n                  const id = generateHeadingId(text);\n                  return (\n                    <h1\n                      id={id}\n                      className=\"text-3xl font-bold text-gray-800 dark:text-white mb-6 mt-2 scroll-mt-20\"\n                      {...props}\n                    >\n                      {children}\n                    </h1>\n                  );\n                },\n                h2: ({ node, children, ...props }) => {\n                  const text = typeof children === \"string\" ? children : \"\";\n                  const id = generateHeadingId(text);\n                  return (\n                    <h2\n                      id={id}\n                      className=\"text-2xl font-semibold text-gray-800 dark:text-white mb-4 mt-10 scroll-mt-20\"\n                      {...props}\n                    >\n                      {children}\n                    </h2>\n                  );\n                },\n                h3: ({ node, children, ...props }) => {\n                  const text = typeof children === \"string\" ? children : \"\";\n                  const id = generateHeadingId(text);\n                  return (\n                    <h3\n                      id={id}\n                      className=\"text-xl font-semibold text-gray-800 dark:text-white mb-3 mt-8 scroll-mt-20\"\n                      {...props}\n                    >\n                      {children}\n                    </h3>\n                  );\n                },\n                h4: ({ node, children, ...props }) => {\n                  const text = typeof children === \"string\" ? children : \"\";\n                  const id = generateHeadingId(text);\n                  return (\n                    <h4\n                      id={id}\n                      className=\"text-lg font-semibold text-gray-800 dark:text-white mb-3 mt-6 scroll-mt-20\"\n                      {...props}\n                    >\n                      {children}\n                    </h4>\n                  );\n                },\n                h5: ({ node, children, ...props }) => {\n                  const text = typeof children === \"string\" ? children : \"\";\n                  const id = generateHeadingId(text);\n                  return (\n                    <h5\n                      id={id}\n                      className=\"text-base font-semibold text-gray-800 dark:text-white mb-2 mt-4 scroll-mt-20\"\n                      {...props}\n                    >\n                      {children}\n                    </h5>\n                  );\n                },\n                h6: ({ node, children, ...props }) => {\n                  const text = typeof children === \"string\" ? children : \"\";\n                  const id = generateHeadingId(text);\n                  return (\n                    <h6\n                      id={id}\n                      className=\"text-sm font-semibold text-gray-800 dark:text-white mb-2 mt-4 scroll-mt-20\"\n                      {...props}\n                    >\n                      {children}\n                    </h6>\n                  );\n                },\n                p: ({ node, ...props }) => (\n                  <p\n                    className=\"text-grey-300 leading-relaxed mb-4\"\n                    {...props}\n                  />\n                ),\n                ul: ({ node, ...props }) => (\n                  <ul\n                    className=\"list-disc list-inside text-grey-300 mb-4 space-y-2\"\n                    {...props}\n                  />\n                ),\n                ol: ({ node, ...props }) => (\n                  <ol\n                    className=\"list-decimal list-inside text-grey-300 mb-4 space-y-2\"\n                    {...props}\n                  />\n                ),\n                li: ({ node, ...props }) => (\n                  <li className=\"text-grey-300\" {...props} />\n                ),\n                a: ({ node, ...props }) => (\n                  <a\n                    className=\"text-teal-400 hover:text-teal-300 hover:underline\"\n                    {...props}\n                  />\n                ),\n                code: ({ node, className, children, ...props }) => {\n                  const isInline = !className?.includes(\"language-\");\n                  const match = /language-(\\w+)/.exec(className || \"\");\n\n                  if (match && match[1] === \"mermaid\") {\n                    const code = String(children).replace(/\\n$/, \"\");\n                    return <MermaidComponent chart={code} />;\n                  }\n                  return isInline ? (\n                    <code\n                      className=\"bg-grey-800 text-teal-400 px-1.5 py-0.5 rounded text-sm\"\n                      {...props}\n                    >\n                      {children}\n                    </code>\n                  ) : (\n                    <code\n                      className=\"block bg-grey-800 text-grey-300 p-4 rounded border border-grey-700 overflow-x-auto\"\n                      {...props}\n                    >\n                      {children}\n                    </code>\n                  );\n                },\n                blockquote: ({ node, ...props }) => (\n                  <blockquote\n                    className=\"border-l-4 border-teal-500 pl-4 italic text-grey-400 my-4\"\n                    {...props}\n                  />\n                ),\n              }}\n            >\n              {selectedFile.content}\n            </ReactMarkdown>\n          </div>\n\n          {selectedFile.referenced_files &&\n            selectedFile.referenced_files.length > 0 && (\n              <div className=\"mt-6 pt-4 border-t border-grey-800\">\n                <h3 className=\"text-xs font-semibold text-grey-400 mb-2\">\n                  Referenced Files\n                </h3>\n                <div className=\"flex flex-wrap gap-2\">\n                  {selectedFile.referenced_files.map((file, i) => (\n                    <button\n                      key={i}\n                      className=\"bg-grey-800 hover:bg-grey-700 rounded px-2 py-1 text-xs text-teal-400 transition-colors font-mono\"\n                    >\n                      {file}\n                    </button>\n                  ))}\n                </div>\n              </div>\n            )}\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1362, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/table-of-contents.tsx"],"sourcesContent":["import { RefreshCw, ArrowUp, X } from \"lucide-react\";\nimport { useEffect, useState } from \"react\";\n\ninterface Page {\n  id: string;\n  title: string;\n}\n\ninterface Heading {\n  id: string;\n  text: string;\n  level: number;\n}\n\ninterface TableOfContentsSidebarProps {\n  selectedFile: Page | null;\n  headings: Heading[];\n  onRefreshClick: () => void;\n  isOpen?: boolean;\n  onClose?: () => void;\n  scrollContainerRef?: React.RefObject<HTMLDivElement | null>;\n}\n\nexport function TableOfContentsSidebar({\n  selectedFile,\n  headings,\n  onRefreshClick,\n  isOpen = false,\n  onClose,\n  scrollContainerRef,\n}: TableOfContentsSidebarProps) {\n  const [activeHeading, setActiveHeading] = useState<string>(\"\");\n  const [showBackToTop, setShowBackToTop] = useState(false);\n\n  useEffect(() => {\n    if (!selectedFile || headings.length === 0) return;\n\n    // Use the passed ref or fall back to querySelector\n    const scrollContainer =\n      scrollContainerRef?.current || document.querySelector(\".overflow-y-auto\");\n    if (!scrollContainer) return;\n\n    const handleScroll = () => {\n      const headingElements = headings\n        .map((heading) => {\n          const element = document.getElementById(heading.id);\n          return { id: heading.id, element };\n        })\n        .filter((item) => item.element) as {\n        id: string;\n        element: HTMLElement;\n      }[];\n\n      if (headingElements.length === 0) return;\n\n      const scrollPosition = scrollContainer.scrollTop + 100;\n\n      for (let i = headingElements.length - 1; i >= 0; i--) {\n        const { id, element } = headingElements[i];\n        if (element.offsetTop <= scrollPosition) {\n          setActiveHeading(id);\n          break;\n        }\n      }\n\n      const scrollPercentage =\n        (scrollContainer.scrollTop /\n          (scrollContainer.scrollHeight - scrollContainer.clientHeight)) *\n        100;\n      setShowBackToTop(scrollPercentage > 50);\n    };\n\n    scrollContainer.addEventListener(\"scroll\", handleScroll);\n    handleScroll();\n\n    return () => scrollContainer.removeEventListener(\"scroll\", handleScroll);\n  }, [selectedFile, headings, scrollContainerRef]);\n\n  const scrollToHeading = (id: string) => {\n    const element = document.getElementById(id);\n    if (element) {\n      // Use the passed ref or find the scroll container\n      const scrollContainer =\n        scrollContainerRef?.current || element.closest(\".overflow-y-auto\");\n      if (scrollContainer) {\n        const offset = 80;\n        const elementPosition = element.offsetTop;\n        const offsetPosition = elementPosition - offset;\n\n        scrollContainer.scrollTo({\n          top: offsetPosition,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  };\n\n  const scrollToTop = () => {\n    // Use the passed ref or find the main content scroll container\n    const scrollContainer =\n      scrollContainerRef?.current || document.querySelector(\".overflow-y-auto\");\n    if (scrollContainer) {\n      scrollContainer.scrollTo({\n        top: 0,\n        behavior: \"smooth\",\n      });\n    }\n  };\n\n  return (\n    <>\n      {/* Mobile backdrop */}\n      {isOpen && onClose && (\n        <div\n          className=\"fixed inset-0 bg-black/50 z-40 xl:hidden\"\n          onClick={onClose}\n        />\n      )}\n\n      {/* Sidebar */}\n      <div\n        className={`\n        w-64 border-l border-border flex flex-col bg-background\n        xl:h-full\n        ${isOpen ? \"fixed right-0 top-0 h-screen z-50\" : \"hidden xl:flex\"}\n      `}\n      >\n        {/* Mobile close button */}\n        {onClose && (\n          <div className=\"xl:hidden p-3 border-b border-border flex items-center justify-between shrink-0\">\n            <span className=\"text-sm font-semibold\">Table of Contents</span>\n            <button onClick={onClose} className=\"p-1 hover:bg-border rounded\">\n              <X className=\"w-4 h-4\" />\n            </button>\n          </div>\n        )}\n\n        {/* Header section */}\n        <div className=\"p-4 border-b border-border flex items-center justify-between shrink-0\">\n          <button\n            onClick={onRefreshClick}\n            className=\"text-xs text-gray-400 hover:text-teal-400 flex items-center gap-1\"\n          >\n            <RefreshCw className=\"w-3 h-3\" />\n            Refresh this wiki\n          </button>\n        </div>\n\n        {/* Scrollable table of contents section */}\n        <div className=\"flex-1 overflow-y-auto\">\n          <div className=\"p-4\">\n            <h3 className=\"text-xs font-semibold text-gray-400 mb-3\">\n              On this page\n            </h3>\n            {selectedFile && (\n              <div className=\"space-y-1\">\n                {headings.map((heading, i) => (\n                  <button\n                    key={i}\n                    onClick={() => {\n                      scrollToHeading(heading.id);\n                      // Close mobile drawer after click\n                      if (onClose) onClose();\n                    }}\n                    className={`block text-xs py-1 transition-colors text-left w-full ${\n                      activeHeading === heading.id\n                        ? \"text-teal-400 font-medium\"\n                        : \"text-gray-400 hover:text-gray-300\"\n                    }`}\n                    style={{ paddingLeft: `${(heading.level - 1) * 12}px` }}\n                  >\n                    {heading.text}\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Back to Top Button */}\n        {showBackToTop && (\n          <div className=\"absolute bottom-4 right-4 shrink-0\">\n            <button\n              onClick={scrollToTop}\n              className=\"w-8 h-8 bg-gray-800 hover:bg-teal-600 border border-gray-700 rounded-full flex items-center justify-center transition-all duration-200 hover:scale-110\"\n              title=\"Back to top\"\n            >\n              <ArrowUp className=\"w-4 h-4 text-gray-300\" />\n            </button>\n          </div>\n        )}\n      </div>\n    </>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1593, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/skeleton.tsx"],"sourcesContent":["import { cn } from \"@/lib/utils\";\n\nfunction Skeleton({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"skeleton\"\n      className={cn(\n        \"bg-accent dark:bg-elevated animate-pulse rounded-md\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\nexport { Skeleton };\n"],"names":[],"mappings":";;;;;AAAA;;;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAoC;IACpE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,uDACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 1617, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/file-tree-skeleton.tsx"],"sourcesContent":["import { Skeleton } from \"@/components/ui/skeleton\";\n\nexport function FileTreeSkeleton() {\n  return (\n    <div className=\"w-64 border-r border-border flex flex-col bg-background h-full hidden lg:flex\">\n      {/* Last indexed section */}\n      <div className=\"p-3 border-b border-border\">\n        <Skeleton className=\"h-4 w-32\" />\n      </div>\n\n      {/* Search bar */}\n      <div className=\"p-2 border-b border-border\">\n        <Skeleton className=\"h-8 w-full rounded\" />\n      </div>\n\n      {/* File tree items */}\n      <div className=\"flex-1 overflow-y-auto p-2 space-y-2\">\n        {/* Root level items */}\n        <Skeleton className=\"h-6 w-[85%]\" style={{ paddingLeft: \"8px\" }} />\n        <Skeleton className=\"h-6 w-[70%]\" style={{ paddingLeft: \"8px\" }} />\n\n        {/* Level 1 indented */}\n        <Skeleton className=\"h-6 w-[80%]\" style={{ paddingLeft: \"20px\" }} />\n        <Skeleton className=\"h-6 w-[75%]\" style={{ paddingLeft: \"20px\" }} />\n\n        {/* Level 2 indented */}\n        <Skeleton className=\"h-6 w-[70%]\" style={{ paddingLeft: \"32px\" }} />\n        <Skeleton className=\"h-6 w-[65%]\" style={{ paddingLeft: \"32px\" }} />\n\n        {/* Root level items */}\n        <Skeleton className=\"h-6 w-[90%]\" style={{ paddingLeft: \"8px\" }} />\n\n        {/* Level 1 indented */}\n        <Skeleton className=\"h-6 w-[75%]\" style={{ paddingLeft: \"20px\" }} />\n        <Skeleton className=\"h-6 w-[60%]\" style={{ paddingLeft: \"20px\" }} />\n\n        {/* More root items */}\n        <Skeleton className=\"h-6 w-[80%]\" style={{ paddingLeft: \"8px\" }} />\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;;;AAEO,SAAS;IACd,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,gJAAQ;oBAAC,WAAU;;;;;;;;;;;0BAItB,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,gJAAQ;oBAAC,WAAU;;;;;;;;;;;0BAItB,8OAAC;gBAAI,WAAU;;kCAEb,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAM;;;;;;kCAC9D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAM;;;;;;kCAG9D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAO;;;;;;kCAC/D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAO;;;;;;kCAG/D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAO;;;;;;kCAC/D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAO;;;;;;kCAG/D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAM;;;;;;kCAG9D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAO;;;;;;kCAC/D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAO;;;;;;kCAG/D,8OAAC,gJAAQ;wBAAC,WAAU;wBAAc,OAAO;4BAAE,aAAa;wBAAM;;;;;;;;;;;;;;;;;;AAItE"}},
    {"offset": {"line": 1777, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/main-content-skeleton.tsx"],"sourcesContent":["import { Skeleton } from \"@/components/ui/skeleton\";\n\nexport function MainContentSkeleton() {\n  return (\n    <div className=\"flex-1 flex flex-col\">\n      {/* Header */}\n      <div className=\"border-b border-grey-800 px-6 py-3 flex items-center justify-between\">\n        <Skeleton className=\"h-7 w-64\" />\n        <Skeleton className=\"h-8 w-40\" />\n      </div>\n\n      {/* Content area */}\n      <div className=\"flex-1 overflow-y-auto bg-grey-950\">\n        <div className=\"max-w-full lg:max-w-4xl mx-4 md:mx-8 lg:ml-24 lg:mr-8 py-8 space-y-6\">\n          {/* H1 Title */}\n          <Skeleton className=\"h-9 w-3/4\" />\n\n          {/* Paragraph block 1 */}\n          <div className=\"space-y-3\">\n            <Skeleton className=\"h-4 w-full\" />\n            <Skeleton className=\"h-4 w-[95%]\" />\n            <Skeleton className=\"h-4 w-[90%]\" />\n            <Skeleton className=\"h-4 w-[70%]\" />\n          </div>\n\n          {/* H2 Heading */}\n          <Skeleton className=\"h-8 w-2/3 mt-10\" />\n\n          {/* Paragraph block 2 */}\n          <div className=\"space-y-3\">\n            <Skeleton className=\"h-4 w-full\" />\n            <Skeleton className=\"h-4 w-[92%]\" />\n            <Skeleton className=\"h-4 w-[85%]\" />\n          </div>\n\n          {/* Code block */}\n          <Skeleton className=\"h-32 w-full bg-grey-800 border border-grey-700\" />\n\n          {/* H3 Heading */}\n          <Skeleton className=\"h-7 w-1/2 mt-8\" />\n\n          {/* Paragraph block 3 */}\n          <div className=\"space-y-3\">\n            <Skeleton className=\"h-4 w-full\" />\n            <Skeleton className=\"h-4 w-[88%]\" />\n            <Skeleton className=\"h-4 w-[95%]\" />\n            <Skeleton className=\"h-4 w-[75%]\" />\n          </div>\n\n          {/* List items */}\n          <div className=\"space-y-2 ml-4\">\n            <Skeleton className=\"h-4 w-[90%]\" />\n            <Skeleton className=\"h-4 w-[85%]\" />\n            <Skeleton className=\"h-4 w-[80%]\" />\n          </div>\n\n          {/* H3 Heading */}\n          <Skeleton className=\"h-7 w-[55%] mt-8\" />\n\n          {/* Paragraph block 4 */}\n          <div className=\"space-y-3\">\n            <Skeleton className=\"h-4 w-full\" />\n            <Skeleton className=\"h-4 w-[93%]\" />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;;;AAEO,SAAS;IACd,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,gJAAQ;wBAAC,WAAU;;;;;;kCACpB,8OAAC,gJAAQ;wBAAC,WAAU;;;;;;;;;;;;0BAItB,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBAAI,WAAU;;sCAEb,8OAAC,gJAAQ;4BAAC,WAAU;;;;;;sCAGpB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;;;;;;;sCAItB,8OAAC,gJAAQ;4BAAC,WAAU;;;;;;sCAGpB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;;;;;;;sCAItB,8OAAC,gJAAQ;4BAAC,WAAU;;;;;;sCAGpB,8OAAC,gJAAQ;4BAAC,WAAU;;;;;;sCAGpB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;;;;;;;sCAItB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;;;;;;;sCAItB,8OAAC,gJAAQ;4BAAC,WAAU;;;;;;sCAGpB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CACpB,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMhC"}},
    {"offset": {"line": 2031, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/table-of-contents-skeleton.tsx"],"sourcesContent":["import { Skeleton } from \"@/components/ui/skeleton\";\n\nexport function TableOfContentsSkeleton() {\n  return (\n    <div className=\"w-64 border-l border-border flex flex-col bg-background hidden xl:flex\">\n      {/* Refresh button section */}\n      <div className=\"p-4 border-b border-border flex items-center justify-between shrink-0\">\n        <Skeleton className=\"h-4 w-32\" />\n      </div>\n\n      {/* Table of contents */}\n      <div className=\"flex-1 overflow-y-auto\">\n        <div className=\"p-4\">\n          {/* \"On this page\" header */}\n          <Skeleton className=\"h-4 w-20 mb-3\" />\n\n          {/* TOC items with varying indentation */}\n          <div className=\"space-y-2\">\n            {/* Root level */}\n            <Skeleton className=\"h-3 w-[75%]\" />\n\n            {/* Level 1 */}\n            <Skeleton className=\"h-3 w-[70%]\" style={{ paddingLeft: \"12px\" }} />\n            <Skeleton className=\"h-3 w-[65%]\" style={{ paddingLeft: \"12px\" }} />\n\n            {/* Level 2 */}\n            <Skeleton className=\"h-3 w-[60%]\" style={{ paddingLeft: \"24px\" }} />\n            <Skeleton className=\"h-3 w-[55%]\" style={{ paddingLeft: \"24px\" }} />\n\n            {/* Level 1 */}\n            <Skeleton className=\"h-3 w-[68%]\" style={{ paddingLeft: \"12px\" }} />\n\n            {/* Root level */}\n            <Skeleton className=\"h-3 w-[72%]\" />\n\n            {/* Level 1 */}\n            <Skeleton className=\"h-3 w-[62%]\" style={{ paddingLeft: \"12px\" }} />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;;;AAEO,SAAS;IACd,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,gJAAQ;oBAAC,WAAU;;;;;;;;;;;0BAItB,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBAAI,WAAU;;sCAEb,8OAAC,gJAAQ;4BAAC,WAAU;;;;;;sCAGpB,8OAAC;4BAAI,WAAU;;8CAEb,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CAGpB,8OAAC,gJAAQ;oCAAC,WAAU;oCAAc,OAAO;wCAAE,aAAa;oCAAO;;;;;;8CAC/D,8OAAC,gJAAQ;oCAAC,WAAU;oCAAc,OAAO;wCAAE,aAAa;oCAAO;;;;;;8CAG/D,8OAAC,gJAAQ;oCAAC,WAAU;oCAAc,OAAO;wCAAE,aAAa;oCAAO;;;;;;8CAC/D,8OAAC,gJAAQ;oCAAC,WAAU;oCAAc,OAAO;wCAAE,aAAa;oCAAO;;;;;;8CAG/D,8OAAC,gJAAQ;oCAAC,WAAU;oCAAc,OAAO;wCAAE,aAAa;oCAAO;;;;;;8CAG/D,8OAAC,gJAAQ;oCAAC,WAAU;;;;;;8CAGpB,8OAAC,gJAAQ;oCAAC,WAAU;oCAAc,OAAO;wCAAE,aAAa;oCAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAM3E"}},
    {"offset": {"line": 2174, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/utils.ts"],"sourcesContent":["import { Page, FileTreeNode, Heading } from './types';\n\nexport function buildFileTree(pages: Page[]): FileTreeNode[] {\n  const nodeMap = new Map<string, FileTreeNode>();\n  const rootNodes: FileTreeNode[] = [];\n\n  pages.forEach(page => {\n    nodeMap.set(page.id, { ...page, children: [] });\n  });\n\n  pages.forEach(page => {\n    const node = nodeMap.get(page.id)!;\n    if (page.parent_page_id === null) {\n      rootNodes.push(node);\n    } else {\n      const parent = nodeMap.get(page.parent_page_id);\n      if (parent) {\n        parent.children.push(node);\n      }\n    }\n  });\n\n  const sortNodes = (nodes: FileTreeNode[]) => {\n    nodes.sort((a, b) => a.order_index - b.order_index);\n    nodes.forEach(node => {\n      if (node.children.length > 0) {\n        sortNodes(node.children);\n      }\n    });\n  };\n  sortNodes(rootNodes);\n\n  return rootNodes;\n}\n\nexport function extractHeadings(content: string): Heading[] {\n  const lines = content.split('\\n');\n  const extractedHeadings: Heading[] = [];\n  \n  lines.forEach((line) => {\n    const match = line.match(/^(#{1,6})\\s+(.+)$/);\n    if (match) {\n      const level = match[1].length;\n      const text = match[2].trim();\n      const id = text.toLowerCase().replace(/[^\\w]+/g, '-');\n      extractedHeadings.push({ id, text, level });\n    }\n  });\n  \n  return extractedHeadings;\n}"],"names":[],"mappings":";;;;;;AAEO,SAAS,cAAc,KAAa;IACzC,MAAM,UAAU,IAAI;IACpB,MAAM,YAA4B,EAAE;IAEpC,MAAM,OAAO,CAAC,CAAA;QACZ,QAAQ,GAAG,CAAC,KAAK,EAAE,EAAE;YAAE,GAAG,IAAI;YAAE,UAAU,EAAE;QAAC;IAC/C;IAEA,MAAM,OAAO,CAAC,CAAA;QACZ,MAAM,OAAO,QAAQ,GAAG,CAAC,KAAK,EAAE;QAChC,IAAI,KAAK,cAAc,KAAK,MAAM;YAChC,UAAU,IAAI,CAAC;QACjB,OAAO;YACL,MAAM,SAAS,QAAQ,GAAG,CAAC,KAAK,cAAc;YAC9C,IAAI,QAAQ;gBACV,OAAO,QAAQ,CAAC,IAAI,CAAC;YACvB;QACF;IACF;IAEA,MAAM,YAAY,CAAC;QACjB,MAAM,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,WAAW,GAAG,EAAE,WAAW;QAClD,MAAM,OAAO,CAAC,CAAA;YACZ,IAAI,KAAK,QAAQ,CAAC,MAAM,GAAG,GAAG;gBAC5B,UAAU,KAAK,QAAQ;YACzB;QACF;IACF;IACA,UAAU;IAEV,OAAO;AACT;AAEO,SAAS,gBAAgB,OAAe;IAC7C,MAAM,QAAQ,QAAQ,KAAK,CAAC;IAC5B,MAAM,oBAA+B,EAAE;IAEvC,MAAM,OAAO,CAAC,CAAC;QACb,MAAM,QAAQ,KAAK,KAAK,CAAC;QACzB,IAAI,OAAO;YACT,MAAM,QAAQ,KAAK,CAAC,EAAE,CAAC,MAAM;YAC7B,MAAM,OAAO,KAAK,CAAC,EAAE,CAAC,IAAI;YAC1B,MAAM,KAAK,KAAK,WAAW,GAAG,OAAO,CAAC,WAAW;YACjD,kBAAkB,IAAI,CAAC;gBAAE;gBAAI;gBAAM;YAAM;QAC3C;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 2233, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/empty.tsx"],"sourcesContent":["// components/ui/empty.tsx\r\nimport { ReactNode } from \"react\";\r\n\r\ninterface EmptyProps {\r\n  title: string;\r\n  description?: string;\r\n  children?: ReactNode;\r\n  icon?: ReactNode;\r\n}\r\n\r\nexport function Empty({ title, description, children, icon }: EmptyProps) {\r\n  return (\r\n    <div className=\"flex flex-col items-center justify-center text-center py-12\">\r\n      {icon && <div className=\"mb-3 rounded-lg bg-muted p-2\">{icon}</div>}\r\n      <h3 className=\"text-lg font-semibold\">{title}</h3>\r\n      {description && (\r\n        <p className=\"text-sm text-muted-foreground mt-2\">{description}</p>\r\n      )}\r\n      {children && <div className=\"mt-4\">{children}</div>}\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;;;AAUnB,SAAS,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,EAAc;IACtE,qBACE,8OAAC;QAAI,WAAU;;YACZ,sBAAQ,8OAAC;gBAAI,WAAU;0BAAgC;;;;;;0BACxD,8OAAC;gBAAG,WAAU;0BAAyB;;;;;;YACtC,6BACC,8OAAC;gBAAE,WAAU;0BAAsC;;;;;;YAEpD,0BAAY,8OAAC;gBAAI,WAAU;0BAAQ;;;;;;;;;;;;AAG1C"}},
    {"offset": {"line": 2287, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAgoCsB,kBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2299, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA6uBsB,2BAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2311, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA+yBsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2323, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAwXsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2335, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/documentation/documentation.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport { Menu, List, FileText, Loader2 } from \"lucide-react\";\nimport { FileTreeSidebar } from \"./file-tree\";\nimport { MainContent } from \"./main-content\";\nimport { TableOfContentsSidebar } from \"./table-of-contents\";\nimport { FileTreeSkeleton } from \"./file-tree-skeleton\";\nimport { MainContentSkeleton } from \"./main-content-skeleton\";\nimport { TableOfContentsSkeleton } from \"./table-of-contents-skeleton\";\nimport { Page, FileTreeNode, Heading } from \"./types\";\nimport { buildFileTree, extractHeadings } from \"./utils\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport { Empty } from \"@/components/ui/empty\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\nimport { useDocumentationStore } from \"@/lib/stores/useDocumentationStore\";\nimport {\n  indexRepository,\n  getDocumentationVersions,\n  getDocPagesForVersion,\n  getRepoWithStatus,\n} from \"@/lib/services/repoService\";\nimport { motion } from \"framer-motion\";\n\nexport default function DocumentationViewer({ repoId }: { repoId: string }) {\n  const [fileTree, setFileTree] = useState<FileTreeNode[]>([]);\n  const [selectedFile, setSelectedFile] = useState<Page | null>(null);\n  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(true);\n  const [headings, setHeadings] = useState<Heading[]>([]);\n  const [showRefreshModal, setShowRefreshModal] = useState(false);\n  const [showGenerateModal, setShowGenerateModal] = useState(false);\n  const [isFileTreeOpen, setIsFileTreeOpen] = useState(false);\n  const [isTocOpen, setIsTocOpen] = useState(false);\n  const [error, setError] = useState(\"\");\n  const mainContentScrollRef = useRef<HTMLDivElement>(null);\n  const setHasDocumentation = useChatUIStore(\n    (state) => state.setHasDocumentation,\n  );\n\n  const selectedVersion = useDocumentationStore(\n    (state) => state.selectedVersion,\n  );\n  const setAvailableVersions = useDocumentationStore(\n    (state) => state.setAvailableVersions,\n  );\n  const selectVersion = useDocumentationStore((state) => state.selectVersion);\n  const isIndexing = useDocumentationStore((state) => state.isIndexing);\n  const setIsIndexing = useDocumentationStore((state) => state.setIsIndexing);\n  const availableVersions = useDocumentationStore(\n    (state) => state.availableVersions,\n  );\n  const setSelectedVersionInChat = useChatUIStore(\n    (state) => state.setSelectedVersion,\n  );\n\n  /*This is a React anti-pattern. Replace with tanstack query later*/\n  useEffect(() => {\n    fetchVersions();\n  }, []);\n\n  useEffect(() => {\n    if (selectedVersion !== null) {\n      // Sync the selected version to the chat store\n      setSelectedVersionInChat(selectedVersion);\n      fetchDocumentation();\n    }\n  }, [selectedVersion, setSelectedVersionInChat]);\n\n  useEffect(() => {\n    if (selectedFile) {\n      const extractedHeadings = extractHeadings(selectedFile.content);\n      setHeadings(extractedHeadings);\n    }\n  }, [selectedFile]);\n\n  const fetchVersions = async () => {\n    try {\n      // Check if repository is still indexing\n      const repoResult = await getRepoWithStatus(repoId);\n\n      if (!repoResult.success) {\n        console.error(\"Error fetching repo status:\", repoResult.error);\n        return;\n      }\n\n      // Don't fetch documentation if still indexing\n      if (repoResult.data.index_status === \"indexing\") {\n        console.log(\"Repository is still indexing, skipping version fetch\");\n        setIsIndexing(true);\n        setIsLoading(false);\n        return;\n      }\n\n      // If we get here, indexing is complete\n      setIsIndexing(false);\n\n      const result = await getDocumentationVersions(repoId);\n\n      if (!result.success) {\n        console.error(\"Error fetching versions:\", result.error);\n        return;\n      }\n\n      // If no documentation versions exist, the repo has never been indexed\n      if (result.data.length === 0) {\n        console.log(\"No documentation versions found\");\n        setIsIndexing(false);\n        setIsLoading(false);\n        return;\n      }\n\n      const versions = result.data.map((doc) => ({\n        version: doc.version ?? 0,\n        createdAt: doc.created_at,\n        updatedAt: doc.updated_at,\n      }));\n\n      setAvailableVersions(versions);\n\n      // Auto-select the latest version\n      if (versions.length > 0) {\n        selectVersion(versions[0].version);\n      }\n    } catch (error) {\n      console.error(\"Error fetching versions:\", error);\n    }\n  };\n\n  const fetchDocumentation = async () => {\n    try {\n      setIsLoading(true);\n\n      if (selectedVersion === null) {\n        setIsLoading(false);\n        return;\n      }\n\n      const result = await getDocPagesForVersion(repoId, selectedVersion);\n\n      if (!result.success) {\n        console.error(\"Error fetching documentation:\", result.error);\n        setFileTree([]);\n        setHasDocumentation(false);\n        setIsLoading(false);\n        return;\n      }\n\n      // Map DocPage[] to Page[]\n      const pages: Page[] = result.data.map((docPage) => {\n        // Helper function to parse JSON fields to string arrays\n        const parseToStringArray = (field: unknown): string[] | null => {\n          if (!field) return null;\n          if (Array.isArray(field)) return field;\n          if (typeof field === \"string\") {\n            try {\n              const parsed = JSON.parse(field);\n              return Array.isArray(parsed) ? parsed : null;\n            } catch {\n              return null;\n            }\n          }\n          return null;\n        };\n\n        return {\n          id: docPage.id,\n          documentation_id: docPage.documentation_id,\n          title: docPage.title ?? \"Untitled\",\n          slug: docPage.slug ?? \"\",\n          content: docPage.content ?? \"\",\n          order_index: docPage.order_index ?? 0,\n          parent_page_id: docPage.parent_page_id,\n          referenced_files: parseToStringArray(docPage.referenced_files),\n          referenced_symbols: parseToStringArray(docPage.referenced_symbols),\n          metadata: docPage.metadata,\n          created_at: docPage.created_at,\n          updated_at: docPage.updated_at ?? docPage.created_at,\n          version: 1, // Default version for now\n        };\n      });\n\n      const tree = buildFileTree(pages);\n      setFileTree(tree);\n\n      // Set the first page as selected if available\n      if (pages.length > 0) {\n        setSelectedFile(pages[0]);\n      }\n\n      // Update chat UI store with documentation availability\n      setHasDocumentation(pages.length > 0);\n    } catch (error) {\n      setHasDocumentation(false);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const toggleExpanded = (nodeId: string) => {\n    setExpandedNodes((prev) => {\n      const next = new Set(prev);\n      if (next.has(nodeId)) {\n        next.delete(nodeId);\n      } else {\n        next.add(nodeId);\n      }\n      return next;\n    });\n  };\n\n  const handleRefresh = async () => {\n    try {\n      setError(\"\");\n      setIsIndexing(true);\n\n      const result = await indexRepository(repoId);\n\n      if (!result.success) {\n        setError(result.error);\n        setIsIndexing(false);\n        return;\n      }\n\n      // Clear client-side documentation state\n      setFileTree([]);\n      setSelectedFile(null);\n      setExpandedNodes(new Set());\n      setHeadings([]);\n      setHasDocumentation(false);\n\n      setShowRefreshModal(false);\n      // Keep isIndexing true - it will be cleared when fetchVersions detects completion\n\n      // Refetch versions to include the new one\n      await fetchVersions();\n    } catch (e) {\n      setError(\"Could not refresh: \" + e);\n      setIsIndexing(false);\n    }\n  };\n\n  const handleGenerate = async () => {\n    try {\n      setError(\"\");\n      setIsIndexing(true);\n\n      const result = await indexRepository(repoId);\n\n      if (!result.success) {\n        setError(result.error);\n        setIsIndexing(false);\n        return;\n      }\n\n      setShowGenerateModal(false);\n      // Keep isIndexing true - it will be cleared when fetchVersions detects completion\n\n      // Refetch versions to include the new one\n      await fetchVersions();\n    } catch (e) {\n      setError(\"Could not generate documentation: \" + e);\n      setIsIndexing(false);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex bg-background h-full\">\n        <FileTreeSkeleton />\n        <MainContentSkeleton />\n        <TableOfContentsSkeleton />\n      </div>\n    );\n  }\n\n  if (isIndexing) {\n    return (\n      <div className=\"flex h-full items-center justify-center bg-background\">\n        <div className=\"flex flex-col items-center gap-4\">\n          <motion.div\n            animate={{ rotate: 360 }}\n            transition={{\n              duration: 1,\n              repeat: Infinity,\n              ease: \"linear\",\n            }}\n          >\n            <Loader2 className=\"h-12 w-12 text-primary\" />\n          </motion.div>\n          <div className=\"text-center\">\n            <h3 className=\"text-lg font-semibold mb-2\">Indexing Repository</h3>\n            <p className=\"text-sm text-muted-foreground max-w-md\">\n              Your codebase is being indexed. This may take a while depending on\n              the size of your repository. You can safely navigate away from\n              this page.\n            </p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (fileTree.length === 0) {\n    return (\n      <>\n        <div className=\"flex h-full items-center justify-center bg-background\">\n          <Empty\n            title=\"No documentation available\"\n            description=\"Index your codebase to generate documentation and enable AI insights.\"\n            icon={<FileText className=\"h-8 w-8\" />}\n          >\n            <Button onClick={() => setShowGenerateModal(true)}>\n              Index Codebase\n            </Button>\n          </Empty>\n        </div>\n\n        <Dialog open={showGenerateModal} onOpenChange={setShowGenerateModal}>\n          <DialogContent>\n            <DialogHeader>\n              <DialogTitle>Index Codebase</DialogTitle>\n              <DialogDescription>\n                This will index your codebase. This process may take a while\n                depending on the size of your repository.\n              </DialogDescription>\n            </DialogHeader>\n            {error && (\n              <div className=\"w-full p-3 bg-destructive/10 text-destructive text-sm rounded-md text-center\">\n                {error}\n              </div>\n            )}\n            <DialogFooter>\n              <Button\n                variant=\"outline\"\n                onClick={() => setShowGenerateModal(false)}\n                className=\"w-full sm:w-auto\"\n                disabled={isIndexing}\n              >\n                Cancel\n              </Button>\n              <Button\n                className=\"w-full sm:w-auto\"\n                onClick={handleGenerate}\n                disabled={isIndexing}\n              >\n                {isIndexing ? (\n                  <div className=\"flex items-center\">\n                    <motion.div\n                      animate={{ rotate: 360 }}\n                      transition={{\n                        duration: 1,\n                        repeat: Infinity,\n                        ease: \"linear\",\n                      }}\n                      className=\"mr-2\"\n                    >\n                      <Loader2 className=\"h-4 w-4\" />\n                    </motion.div>\n                    Indexing...\n                  </div>\n                ) : (\n                  \"Index\"\n                )}\n              </Button>\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n      </>\n    );\n  }\n\n  return (\n    <div className=\"flex bg-background h-full\">\n      {/* Mobile toggle buttons */}\n      <div className=\"fixed bottom-20 left-4 z-30 flex flex-col gap-2 lg:hidden\">\n        <Button\n          size=\"icon\"\n          variant=\"default\"\n          onClick={() => setIsFileTreeOpen(true)}\n          className=\"shadow-lg\"\n          aria-label=\"Open file tree\"\n        >\n          <Menu className=\"h-5 w-5\" />\n        </Button>\n      </div>\n\n      <div className=\"fixed bottom-20 right-4 z-30 flex flex-col gap-2 xl:hidden\">\n        <Button\n          size=\"icon\"\n          variant=\"default\"\n          onClick={() => setIsTocOpen(true)}\n          className=\"shadow-lg\"\n          aria-label=\"Open table of contents\"\n        >\n          <List className=\"h-5 w-5\" />\n        </Button>\n      </div>\n\n      <FileTreeSidebar\n        fileTree={fileTree}\n        selectedFile={selectedFile}\n        expandedNodes={expandedNodes}\n        searchQuery={searchQuery}\n        lastIndexed={\n          availableVersions.find(\n            (version) => version.version === selectedVersion,\n          )?.updatedAt ?? \"\"\n        }\n        onSelectFile={setSelectedFile}\n        onToggleExpanded={toggleExpanded}\n        onSearchChange={setSearchQuery}\n        isOpen={isFileTreeOpen}\n        onClose={() => setIsFileTreeOpen(false)}\n      />\n\n      <MainContent\n        selectedFile={selectedFile}\n        scrollContainerRef={mainContentScrollRef}\n      />\n\n      <TableOfContentsSidebar\n        selectedFile={selectedFile}\n        headings={headings}\n        onRefreshClick={() => setShowRefreshModal(true)}\n        isOpen={isTocOpen}\n        onClose={() => setIsTocOpen(false)}\n        scrollContainerRef={mainContentScrollRef}\n      />\n\n      <Dialog open={showRefreshModal} onOpenChange={setShowRefreshModal}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Refresh this wiki</DialogTitle>\n            <DialogDescription>\n              This action will reindex your codebase and create a new version.\n              The process may take a while depending on the size of your\n              repository.\n            </DialogDescription>\n          </DialogHeader>\n          {error && (\n            <div className=\"w-full p-3 bg-destructive/10 text-destructive text-sm rounded-md text-center\">\n              {error}\n            </div>\n          )}\n          <DialogFooter>\n            <Button\n              variant=\"outline\"\n              onClick={() => setShowRefreshModal(false)}\n              className=\"w-full sm:w-auto\"\n              disabled={isIndexing}\n            >\n              Cancel\n            </Button>\n            <Button\n              className=\"w-full sm:w-auto\"\n              onClick={handleRefresh}\n              disabled={isIndexing}\n            >\n              {isIndexing ? (\n                <div className=\"flex items-center\">\n                  <motion.div\n                    animate={{ rotate: 360 }}\n                    transition={{\n                      duration: 1,\n                      repeat: Infinity,\n                      ease: \"linear\",\n                    }}\n                    className=\"mr-2\"\n                  >\n                    <Loader2 className=\"h-4 w-4\" />\n                  </motion.div>\n                  Reindexing...\n                </div>\n              ) : (\n                \"Refresh\"\n              )}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3019, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/chat-bubble.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { useState } from \"react\";\nimport { motion } from \"framer-motion\";\nimport { Send } from \"lucide-react\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\n\nexport default function ChatBubble() {\n  const [inputValue, setInputValue] = useState(\"\");\n  const expand = useChatUIStore((state) => state.expand);\n  const isExpanded = useChatUIStore((state) => state.isExpanded);\n  const hasDocumentation = useChatUIStore((state) => state.hasDocumentation);\n\n  const handleSend = () => {\n    if (inputValue.trim()) {\n      // Expand to full chat and pass the message\n      expand(inputValue);\n      setInputValue(\"\");\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n\n  // Hide chat bubble if documentation doesn't exist or chat is expanded\n  if (isExpanded || !hasDocumentation) {\n    return null;\n  }\n\n  return (\n    <div className=\"fixed bottom-6 left-1/2 -translate-x-1/2 z-50 w-[calc(100%-2rem)] sm:w-[400px] md:w-[500px] lg:w-[600px] xl:w-[700px]\">\n      <motion.div\n        layoutId=\"chat-container\"\n        className=\"w-full mx-auto\"\n        style={{ borderRadius: 8 }}\n      >\n        <div className=\"relative\">\n          <textarea\n            placeholder=\"Ask about this codebase\"\n            value={inputValue}\n            onChange={(e) => setInputValue(e.target.value)}\n            onKeyDown={handleKeyDown}\n            rows={2}\n            className=\"w-full bg-white dark:bg-background backdrop-blur-md text-gray-900 dark:text-gray-100 px-4 py-3 pr-12 rounded-lg border border-gray-300 dark:border-border focus:outline-none\n                      focus:ring-2 focus:ring-teal-500/50 focus:border-teal-500/50 focus:shadow-[0_0_15px_rgba(20,184,166,0.3)]\n                      placeholder-gray-400 dark:placeholder-gray-500 resize-none disabled:cursor-not-allowed\n                      transition-shadow duration-200 opacity-90\"\n          />\n          <button\n            onClick={handleSend}\n            disabled={!inputValue.trim()}\n            className=\"absolute bottom-3 right-3 p-2 text-teal-500 hover:text-teal-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            <Send size={20} />\n          </button>\n        </div>\n      </motion.div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAOe,SAAS;IACtB,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAC7C,MAAM,SAAS,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,MAAM;IACrD,MAAM,aAAa,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,UAAU;IAC7D,MAAM,mBAAmB,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,gBAAgB;IAEzE,MAAM,aAAa;QACjB,IAAI,WAAW,IAAI,IAAI;YACrB,2CAA2C;YAC3C,OAAO;YACP,cAAc;QAChB;IACF;IAEA,MAAM,gBAAgB,CAAC;QACrB,IAAI,EAAE,GAAG,KAAK,WAAW,CAAC,EAAE,QAAQ,EAAE;YACpC,EAAE,cAAc;YAChB;QACF;IACF;IAEA,sEAAsE;IACtE,IAAI,cAAc,CAAC,kBAAkB;QACnC,OAAO;IACT;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC,oMAAM,CAAC,GAAG;YACT,UAAS;YACT,WAAU;YACV,OAAO;gBAAE,cAAc;YAAE;sBAEzB,cAAA,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBACC,aAAY;wBACZ,OAAO;wBACP,UAAU,CAAC,IAAM,cAAc,EAAE,MAAM,CAAC,KAAK;wBAC7C,WAAW;wBACX,MAAM;wBACN,WAAU;;;;;;kCAKZ,8OAAC;wBACC,SAAS;wBACT,UAAU,CAAC,WAAW,IAAI;wBAC1B,WAAU;kCAEV,cAAA,8OAAC,0MAAI;4BAAC,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMxB"}},
    {"offset": {"line": 3116, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/animated-skeleton.tsx"],"sourcesContent":["\"use client\";\n\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { motion } from \"framer-motion\";\nimport { useEffect, useRef } from \"react\";\n\nconst skeletonLines = [\n  \"100%\",\n  \"90%\",\n  \"95%\",\n  \"70%\",\n  \"80%\",\n  \"92%\",\n  \"100%\",\n  \"90%\",\n  \"95%\",\n  \"70%\",\n  \"80%\",\n  \"92%\",\n];\n\nexport default function AnimatedSkeleton() {\n  const skeletonRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (skeletonRef.current) {\n      skeletonRef.current.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"nearest\",\n      });\n    }\n  }, []);\n\n  return (\n    <motion.div\n      ref={skeletonRef}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.3 }}\n      className=\"mt-5 bg-elevated rounded-sm\"\n    >\n      <div className=\"space-y-3 p-4\">\n        {skeletonLines.map((width, index) => (\n          <motion.div\n            key={index}\n            initial={{ width: 0 }}\n            animate={{ width }}\n            transition={{\n              duration: 0.6,\n              ease: \"easeOut\",\n              delay: index * 0.05,\n            }}\n          >\n            <Skeleton className={`h-4 w-[${width}] dark:bg-accent `} />\n          </motion.div>\n        ))}\n      </div>\n    </motion.div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAMA,MAAM,gBAAgB;IACpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEc,SAAS;IACtB,MAAM,cAAc,IAAA,+MAAM,EAAiB;IAE3C,IAAA,kNAAS,EAAC;QACR,IAAI,YAAY,OAAO,EAAE;YACvB,YAAY,OAAO,CAAC,cAAc,CAAC;gBACjC,UAAU;gBACV,OAAO;YACT;QACF;IACF,GAAG,EAAE;IAEL,qBACE,8OAAC,oMAAM,CAAC,GAAG;QACT,KAAK;QACL,SAAS;YAAE,SAAS;QAAE;QACtB,SAAS;YAAE,SAAS;QAAE;QACtB,YAAY;YAAE,UAAU;QAAI;QAC5B,WAAU;kBAEV,cAAA,8OAAC;YAAI,WAAU;sBACZ,cAAc,GAAG,CAAC,CAAC,OAAO,sBACzB,8OAAC,oMAAM,CAAC,GAAG;oBAET,SAAS;wBAAE,OAAO;oBAAE;oBACpB,SAAS;wBAAE;oBAAM;oBACjB,YAAY;wBACV,UAAU;wBACV,MAAM;wBACN,OAAO,QAAQ;oBACjB;8BAEA,cAAA,8OAAC,gJAAQ;wBAAC,WAAW,CAAC,OAAO,EAAE,MAAM,iBAAiB,CAAC;;;;;;mBATlD;;;;;;;;;;;;;;;AAejB"}},
    {"offset": {"line": 3206, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/message-bubble.tsx"],"sourcesContent":["\"use client\";\n\nimport { ArrowLeft, Copy, Share2 } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\nimport ReactMarkdown from \"react-markdown\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { vscDarkPlus } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\ninterface MessageBubbleProps {\n  id: string;\n  text: string;\n  sender: \"user\" | \"assistant\";\n  timestamp: string;\n}\n\nexport default function MessageBubble({ text, sender }: MessageBubbleProps) {\n  const { minimize } = useChatUIStore();\n\n  if (sender === \"user\") {\n    return (\n      <div className=\"mb-8 flex flex-row gap-6 px-5\">\n        <div className=\"text-gray-700 dark:text-gray-300 tracking-wide text-2xl leading-relaxed\">\n          {text}\n        </div>\n\n        <Button variant=\"ghost\" onClick={minimize} aria-label=\"Close chat\">\n          <ArrowLeft className=\"h-5 w-5\" />\n          Back to documentation\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"mb-8\">\n      <div className=\"mt-6\">\n        <div className=\"bg-elevated rounded-lg border border-gray-800 p-6\">\n          <div className=\"prose prose-invert max-w-none\">\n            <ReactMarkdown\n              components={{\n                h1: ({ node, ...props }) => (\n                  <h1\n                    className=\"text-2xl font-bold text-gray-800 dark:text-white mb-4 mt-2\"\n                    {...props}\n                  />\n                ),\n                h2: ({ node, ...props }) => (\n                  <h2\n                    className=\"text-xl font-semibold text-gray-800 dark:text-white mb-3 mt-6\"\n                    {...props}\n                  />\n                ),\n                h3: ({ node, ...props }) => (\n                  <h3\n                    className=\"text-lg font-semibold text-gray-800 dark:text-white mb-2 mt-4\"\n                    {...props}\n                  />\n                ),\n                h4: ({ node, ...props }) => (\n                  <h4\n                    className=\"text-base font-semibold text-gray-800 dark:text-white mb-2 mt-3\"\n                    {...props}\n                  />\n                ),\n                h5: ({ node, ...props }) => (\n                  <h5\n                    className=\"text-sm font-semibold text-gray-800 dark:text-white mb-1 mt-2\"\n                    {...props}\n                  />\n                ),\n                h6: ({ node, ...props }) => (\n                  <h6\n                    className=\"text-xs font-semibold text-gray-800 dark:text-white mb-1 mt-2\"\n                    {...props}\n                  />\n                ),\n                p: ({ node, ...props }) => (\n                  <p\n                    className=\"text-gray-700 dark:text-gray-300 leading-relaxed mb-4\"\n                    {...props}\n                  />\n                ),\n                ul: ({ node, ...props }) => (\n                  <ul\n                    className=\"list-disc list-inside text-gray-700 dark:text-gray-300 mb-4 space-y-1\"\n                    {...props}\n                  />\n                ),\n                ol: ({ node, ...props }) => (\n                  <ol\n                    className=\"list-decimal list-inside text-gray-700 dark:text-gray-300 mb-4 space-y-1\"\n                    {...props}\n                  />\n                ),\n                li: ({ node, ...props }) => (\n                  <li className=\"text-gray-700 dark:text-gray-300\" {...props} />\n                ),\n                a: ({ node, ...props }) => (\n                  <a\n                    className=\"text-teal-400 hover:text-teal-300 hover:underline\"\n                    {...props}\n                  />\n                ),\n                code: ({ node, className, children, ...props }) => {\n                  const isInline = !className?.includes(\"language-\");\n                  const match = /language-(\\w+)/.exec(className || \"\");\n                  const language = match ? match[1] : \"text\";\n\n                  return isInline ? (\n                    <code\n                      className=\"bg-gray-800 text-teal-400 px-1.5 py-0.5 rounded text-sm font-mono\"\n                      {...props}\n                    >\n                      {children}\n                    </code>\n                  ) : (\n                    <SyntaxHighlighter\n                      language={language}\n                      style={vscDarkPlus}\n                      showLineNumbers={true}\n                      customStyle={{\n                        background: \"#1e1e1e\",\n                        padding: \"1rem\",\n                        fontSize: \"12px\",\n                        borderRadius: \"0.375rem\",\n                        marginBottom: \"1rem\",\n                      }}\n                    >\n                      {String(children).replace(/\\n$/, \"\")}\n                    </SyntaxHighlighter>\n                  );\n                },\n                blockquote: ({ node, ...props }) => (\n                  <blockquote\n                    className=\"border-l-4 border-teal-500 pl-4 italic text-gray-400 my-4\"\n                    {...props}\n                  />\n                ),\n                pre: ({ node, ...props }) => (\n                  <pre className=\"mb-4\" {...props} />\n                ),\n              }}\n            >\n              {text}\n            </ReactMarkdown>\n          </div>\n          <div className=\"flex gap-2 mt-4 pt-4 border-t border-gray-800\">\n            <button className=\"p-2 hover:bg-gray-800 rounded-md transition-colors\">\n              <Copy size={16} className=\"text-gray-400\" />\n            </button>\n            <button className=\"p-2 hover:bg-gray-800 rounded-md transition-colors\">\n              <Share2 size={16} className=\"text-gray-400\" />\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAPA;;;;;;;;AAgBe,SAAS,cAAc,EAAE,IAAI,EAAE,MAAM,EAAsB;IACxE,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAA,wJAAc;IAEnC,IAAI,WAAW,QAAQ;QACrB,qBACE,8OAAC;YAAI,WAAU;;8BACb,8OAAC;oBAAI,WAAU;8BACZ;;;;;;8BAGH,8OAAC,4IAAM;oBAAC,SAAQ;oBAAQ,SAAS;oBAAU,cAAW;;sCACpD,8OAAC,6NAAS;4BAAC,WAAU;;;;;;wBAAY;;;;;;;;;;;;;IAKzC;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC,mMAAa;4BACZ,YAAY;gCACV,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,GAAG,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACpB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,IAAI,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACrB,8OAAC;wCAAG,WAAU;wCAAoC,GAAG,KAAK;;;;;;gCAE5D,GAAG,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACpB,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,MAAM,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO;oCAC5C,MAAM,WAAW,CAAC,WAAW,SAAS;oCACtC,MAAM,QAAQ,iBAAiB,IAAI,CAAC,aAAa;oCACjD,MAAM,WAAW,QAAQ,KAAK,CAAC,EAAE,GAAG;oCAEpC,OAAO,yBACL,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;kDAER;;;;;+DAGH,8OAAC,mNAAiB;wCAChB,UAAU;wCACV,OAAO,gQAAW;wCAClB,iBAAiB;wCACjB,aAAa;4CACX,YAAY;4CACZ,SAAS;4CACT,UAAU;4CACV,cAAc;4CACd,cAAc;wCAChB;kDAEC,OAAO,UAAU,OAAO,CAAC,OAAO;;;;;;gCAGvC;gCACA,YAAY,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBAC7B,8OAAC;wCACC,WAAU;wCACT,GAAG,KAAK;;;;;;gCAGb,KAAK,CAAC,EAAE,IAAI,EAAE,GAAG,OAAO,iBACtB,8OAAC;wCAAI,WAAU;wCAAQ,GAAG,KAAK;;;;;;4BAEnC;sCAEC;;;;;;;;;;;kCAGL,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAO,WAAU;0CAChB,cAAA,8OAAC,0MAAI;oCAAC,MAAM;oCAAI,WAAU;;;;;;;;;;;0CAE5B,8OAAC;gCAAO,WAAU;0CAChB,cAAA,8OAAC,oNAAM;oCAAC,MAAM;oCAAI,WAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAO1C"}},
    {"offset": {"line": 3484, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/message-list.tsx"],"sourcesContent":["import AnimatedSkeleton from \"./animated-skeleton\";\nimport MessageBubble from \"./message-bubble\";\n\ninterface Message {\n  id: string;\n  text: string;\n  sender: \"user\" | \"assistant\";\n  timestamp: string;\n}\n\ninterface MessageListProps {\n  messages: Message[];\n  loading: boolean;\n}\n\nexport default function MessageList({ messages, loading }: MessageListProps) {\n  return (\n    <div className=\"flex-1 overflow-y-auto\">\n      <div className=\"max-w-3xl mx-auto px-4 py-4\">\n        {messages.map((message) => (\n          <MessageBubble\n            key={message.id}\n            id={message.id}\n            text={message.text}\n            sender={message.sender}\n            timestamp={message.timestamp}\n          />\n        ))}\n        {loading && <AnimatedSkeleton />}\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;;;;AAce,SAAS,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAoB;IACzE,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;;gBACZ,SAAS,GAAG,CAAC,CAAC,wBACb,8OAAC,uKAAa;wBAEZ,IAAI,QAAQ,EAAE;wBACd,MAAM,QAAQ,IAAI;wBAClB,QAAQ,QAAQ,MAAM;wBACtB,WAAW,QAAQ,SAAS;uBAJvB,QAAQ,EAAE;;;;;gBAOlB,yBAAW,8OAAC,0KAAgB;;;;;;;;;;;;;;;;AAIrC"}},
    {"offset": {"line": 3531, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/chat-input.tsx"],"sourcesContent":["\"use client\";\nimport { Send } from \"lucide-react\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\n\ninterface ChatInputProps {\n  value: string;\n  onChange: (value: string) => void;\n  onSend: () => void;\n  disabled: boolean;\n}\n\nexport default function ChatInput({\n  value,\n  onChange,\n  onSend,\n  disabled,\n}: ChatInputProps) {\n  const { initialMessage } = useChatUIStore();\n\n  const handleKeyPress = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === \"Enter\" && !e.shiftKey && !disabled) {\n      e.preventDefault();\n      onSend();\n    }\n  };\n\n  return (\n    <div className=\"border-t dark:border-gray-800 bg-background\">\n      <div className=\"max-w-4xl mx-auto px-4 py-4\">\n        <div className=\"relative\">\n          <textarea\n            value={value}\n            onChange={(e) => onChange(e.target.value)}\n            onKeyPress={handleKeyPress}\n            placeholder={\n              initialMessage ? \"Ask a follow-up question\" : \"Ask CodeCompass\"\n            }\n            rows={2}\n            disabled={disabled}\n            className=\"w-full bg-background text-gray-100 px-4 py-3 pr-12 rounded-lg border dark:border-gray-700 focus:outline-none\n                    focus:ring-2 focus:ring-teal-500/50 focus:border-teal-500/50 focus:shadow-[0_0_15px_rgba(20,184,166,0.3)]\n                    placeholder-gray-500 resize-none disabled:opacity-50 disabled:cursor-not-allowed\n                    transition-shadow duration-200\"\n          />\n          <button\n            onClick={onSend}\n            className=\"absolute bottom-3 right-3 p-2 text-teal-500 hover:text-teal-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n            disabled={!value.trim() || disabled}\n          >\n            <Send size={20} />\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AACA;AACA;AAFA;;;;AAWe,SAAS,UAAU,EAChC,KAAK,EACL,QAAQ,EACR,MAAM,EACN,QAAQ,EACO;IACf,MAAM,EAAE,cAAc,EAAE,GAAG,IAAA,wJAAc;IAEzC,MAAM,iBAAiB,CAAC;QACtB,IAAI,EAAE,GAAG,KAAK,WAAW,CAAC,EAAE,QAAQ,IAAI,CAAC,UAAU;YACjD,EAAE,cAAc;YAChB;QACF;IACF;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBACC,OAAO;wBACP,UAAU,CAAC,IAAM,SAAS,EAAE,MAAM,CAAC,KAAK;wBACxC,YAAY;wBACZ,aACE,iBAAiB,6BAA6B;wBAEhD,MAAM;wBACN,UAAU;wBACV,WAAU;;;;;;kCAKZ,8OAAC;wBACC,SAAS;wBACT,WAAU;wBACV,UAAU,CAAC,MAAM,IAAI,MAAM;kCAE3B,cAAA,8OAAC,0MAAI;4BAAC,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMxB"}},
    {"offset": {"line": 3607, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/code-snippet.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Copy, Check } from \"lucide-react\";\nimport { useState } from \"react\";\n\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\n\nimport { vscDarkPlus } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nexport default function CodeSnippet({\n  file,\n  code,\n}: {\n  file: string;\n  code: string;\n}) {\n  const [copied, setCopied] = useState(false);\n\n  const handleCopy = async () => {\n    try {\n      await navigator.clipboard.writeText(code);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (err) {\n      console.error(\"Failed to copy:\", err);\n    }\n  };\n\n  return (\n    <div className=\"bg-elevated rounded-sm\">\n      <Dialog>\n        <div className=\"flex flex-row\">\n          <DialogTrigger asChild>\n            <button className=\"font-sans text-xs pl-2 pt-1 hover:text-primary transition-colors cursor-pointer\">\n              {file}\n            </button>\n          </DialogTrigger>\n        </div>\n        <SyntaxHighlighter\n          language=\"javascript\"\n          style={vscDarkPlus}\n          showLineNumbers={true}\n          customStyle={{\n            background: \"#1e1e1e\",\n            padding: \"1rem\",\n            fontSize: \"11px\",\n          }}\n        >\n          {code}\n        </SyntaxHighlighter>\n\n        <DialogContent className=\"max-w-[90vw] max-h-[90vh] overflow-hidden flex flex-col\">\n          <DialogHeader>\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <DialogTitle>{file}</DialogTitle>\n                <DialogDescription>Full file content</DialogDescription>\n              </div>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={handleCopy}\n                className=\"gap-2\"\n              >\n                {copied ? (\n                  <>\n                    <Check className=\"h-4 w-4\" />\n                    Copied\n                  </>\n                ) : (\n                  <>\n                    <Copy className=\"h-4 w-4\" />\n                    Copy\n                  </>\n                )}\n              </Button>\n            </div>\n          </DialogHeader>\n          <div className=\"flex-1 overflow-auto\">\n            <SyntaxHighlighter\n              language=\"javascript\"\n              style={vscDarkPlus}\n              showLineNumbers={true}\n              customStyle={{\n                background: \"#1e1e1e\",\n                padding: \"1rem\",\n                fontSize: \"12px\",\n                margin: 0,\n              }}\n            >\n              {code}\n            </SyntaxHighlighter>\n          </div>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAQA;AACA;AAAA;AACA;AAEA;AAEA;AAhBA;;;;;;;;AAkBe,SAAS,YAAY,EAClC,IAAI,EACJ,IAAI,EAIL;IACC,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,iNAAQ,EAAC;IAErC,MAAM,aAAa;QACjB,IAAI;YACF,MAAM,UAAU,SAAS,CAAC,SAAS,CAAC;YACpC,UAAU;YACV,WAAW,IAAM,UAAU,QAAQ;QACrC,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,mBAAmB;QACnC;IACF;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC,4IAAM;;8BACL,8OAAC;oBAAI,WAAU;8BACb,cAAA,8OAAC,mJAAa;wBAAC,OAAO;kCACpB,cAAA,8OAAC;4BAAO,WAAU;sCACf;;;;;;;;;;;;;;;;8BAIP,8OAAC,mNAAiB;oBAChB,UAAS;oBACT,OAAO,gQAAW;oBAClB,iBAAiB;oBACjB,aAAa;wBACX,YAAY;wBACZ,SAAS;wBACT,UAAU;oBACZ;8BAEC;;;;;;8BAGH,8OAAC,mJAAa;oBAAC,WAAU;;sCACvB,8OAAC,kJAAY;sCACX,cAAA,8OAAC;gCAAI,WAAU;;kDACb,8OAAC;;0DACC,8OAAC,iJAAW;0DAAE;;;;;;0DACd,8OAAC,uJAAiB;0DAAC;;;;;;;;;;;;kDAErB,8OAAC,4IAAM;wCACL,SAAQ;wCACR,MAAK;wCACL,SAAS;wCACT,WAAU;kDAET,uBACC;;8DACE,8OAAC,6MAAK;oDAAC,WAAU;;;;;;gDAAY;;yEAI/B;;8DACE,8OAAC,0MAAI;oDAAC,WAAU;;;;;;gDAAY;;;;;;;;;;;;;;;;;;;sCAOtC,8OAAC;4BAAI,WAAU;sCACb,cAAA,8OAAC,mNAAiB;gCAChB,UAAS;gCACT,OAAO,gQAAW;gCAClB,iBAAiB;gCACjB,aAAa;oCACX,YAAY;oCACZ,SAAS;oCACT,UAAU;oCACV,QAAQ;gCACV;0CAEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOf"}},
    {"offset": {"line": 3797, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/answer-panel.tsx"],"sourcesContent":["\"use client\";\n\nimport AnimatedSkeleton from \"./animated-skeleton\";\nimport CodeSnippet from \"./code-snippet\";\n\ninterface CodeSnippet {\n  file: string;\n  code: string;\n}\n\ninterface ConversationTurn {\n  id: number;\n  userQuestion: string;\n  timestamp: string;\n  codeSnippets: CodeSnippet[];\n  loading: boolean;\n}\n\ninterface AnswerPanelProps {\n  conversationTurns: ConversationTurn[];\n}\n\nexport default function AnswerPanel({ conversationTurns }: AnswerPanelProps) {\n  return (\n    <div className=\"flex-1 border-l border-gray-200 dark:border-gray-800 bg-white dark:bg-background overflow-y-auto\">\n      <div className=\"px-6 py-4\">\n        {conversationTurns.length === 0 ? (\n          <div className=\"text-center text-gray-500 mt-12\">\n            <p className=\"text-sm mt-2\">\n              Relevant code snippets will appear here, grouped by your questions\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-8\">\n            {conversationTurns.map((turn) => (\n              <div key={turn.id} className=\"space-y-3\">\n                {/* Question Header */}\n                <div className=\"sticky top-0 bg-white dark:bg-background py-2 border-b border-gray-200 dark:border-gray-800\">\n                  <p className=\"text-sm text-gray-700 dark:text-gray-400 font-medium\">\n                    {turn.userQuestion}\n                  </p>\n                  <p className=\"text-xs text-gray-500 dark:text-gray-600 mt-1\">\n                    {turn.timestamp}\n                  </p>\n                </div>\n\n                {/* Code Snippets for this question */}\n                <div className=\"space-y-4\">\n                  {turn.loading ? (\n                    <AnimatedSkeleton />\n                  ) : turn.codeSnippets.length > 0 ? (\n                    turn.codeSnippets.map((snippet, index) => (\n                      <CodeSnippet\n                        key={`${turn.id}-${index}`}\n                        file={snippet.file}\n                        code={snippet.code}\n                      />\n                    ))\n                  ) : (\n                    <p className=\"text-xs text-gray-500 dark:text-gray-600 italic\">\n                      No code snippets for this question\n                    </p>\n                  )}\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAHA;;;;AAsBe,SAAS,YAAY,EAAE,iBAAiB,EAAoB;IACzE,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;sBACZ,kBAAkB,MAAM,KAAK,kBAC5B,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBAAE,WAAU;8BAAe;;;;;;;;;;qCAK9B,8OAAC;gBAAI,WAAU;0BACZ,kBAAkB,GAAG,CAAC,CAAC,qBACtB,8OAAC;wBAAkB,WAAU;;0CAE3B,8OAAC;gCAAI,WAAU;;kDACb,8OAAC;wCAAE,WAAU;kDACV,KAAK,YAAY;;;;;;kDAEpB,8OAAC;wCAAE,WAAU;kDACV,KAAK,SAAS;;;;;;;;;;;;0CAKnB,8OAAC;gCAAI,WAAU;0CACZ,KAAK,OAAO,iBACX,8OAAC,0KAAgB;;;;2CACf,KAAK,YAAY,CAAC,MAAM,GAAG,IAC7B,KAAK,YAAY,CAAC,GAAG,CAAC,CAAC,SAAS,sBAC9B,8OAAC,qKAAW;wCAEV,MAAM,QAAQ,IAAI;wCAClB,MAAM,QAAQ,IAAI;uCAFb,GAAG,KAAK,EAAE,CAAC,CAAC,EAAE,OAAO;;;;8DAM9B,8OAAC;oCAAE,WAAU;8CAAkD;;;;;;;;;;;;uBAxB3D,KAAK,EAAE;;;;;;;;;;;;;;;;;;;;AAoC/B"}},
    {"offset": {"line": 3909, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/chat-empty-state.tsx"],"sourcesContent":["\"use client\";\n\nimport { Sparkles } from \"lucide-react\";\n\ninterface ChatEmptyStateProps {\n  onSendMessage: (message: string) => void;\n}\n\nexport default function ChatEmptyState({ onSendMessage }: ChatEmptyStateProps) {\n  const time = new Date().getHours();\n\n  const suggestions = [\n    \"Explain this codebase structure\",\n    \"How does authentication work?\",\n  ];\n\n  const handleSuggestionClick = (suggestion: string) => {\n    onSendMessage(suggestion);\n  };\n\n  return (\n    <div className=\"flex-1 flex flex-col items-center justify-center px-8 pb-32\">\n      {/* Greeting */}\n      <div className=\"mb-8 text-center\">\n        <h1 className=\"text-3xl font-normal dark:text-gray-100 mb-2\">\n          <Sparkles className=\"inline-block h-8 w-8 mr-2 text-teal-500\" />\n          {time < 12\n            ? \"Good Morning\"\n            : time < 17\n              ? \"Good Afternoon\"\n              : \"Good Evening\"}\n        </h1>\n        <p className=\"dark:text-gray-400\">\n          Ask me anything about this codebase\n        </p>\n      </div>\n\n      {/* Suggested Prompts */}\n      <div className=\"w-full max-w-2xl\">\n        <p className=\"text-sm text-gray-400 mb-3\">Suggested prompts:</p>\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\">\n          {suggestions.map((suggestion, index) => (\n            <button\n              key={index}\n              onClick={() => handleSuggestionClick(suggestion)}\n              className=\"px-4 py-3 bg-background border dark:border-gray-700 rounded-lg\n                       text-left text-sm dark:text-gray-200 hover:bg-gray-750\n                       hover:border-teal-500/50 transition-all duration-200\n                       hover:shadow-[0_0_10px_rgba(20,184,166,0.2)]\"\n            >\n              {suggestion}\n            </button>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AAQe,SAAS,eAAe,EAAE,aAAa,EAAuB;IAC3E,MAAM,OAAO,IAAI,OAAO,QAAQ;IAEhC,MAAM,cAAc;QAClB;QACA;KACD;IAED,MAAM,wBAAwB,CAAC;QAC7B,cAAc;IAChB;IAEA,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAG,WAAU;;0CACZ,8OAAC,sNAAQ;gCAAC,WAAU;;;;;;4BACnB,OAAO,KACJ,iBACA,OAAO,KACL,mBACA;;;;;;;kCAER,8OAAC;wBAAE,WAAU;kCAAqB;;;;;;;;;;;;0BAMpC,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAE,WAAU;kCAA6B;;;;;;kCAC1C,8OAAC;wBAAI,WAAU;kCACZ,YAAY,GAAG,CAAC,CAAC,YAAY,sBAC5B,8OAAC;gCAEC,SAAS,IAAM,sBAAsB;gCACrC,WAAU;0CAKT;+BAPI;;;;;;;;;;;;;;;;;;;;;;AAcnB"}},
    {"offset": {"line": 4008, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/model-selector.tsx"],"sourcesContent":["\"use client\";\n\nimport { Check, ChevronDown } from \"lucide-react\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\n\nexport interface LLMModel {\n  id: string;\n  name: string;\n  provider: string;\n}\n\nexport const AVAILABLE_MODELS: LLMModel[] = [\n  {\n    id: \"gpt-4\",\n    name: \"GPT-4\",\n    provider: \"OpenAI\",\n  },\n  {\n    id: \"claude-4.5-sonnet\",\n    name: \"Claude 4.5 Sonnet\",\n    provider: \"Anthropic\",\n  },\n  {\n    id: \"llama-4\",\n    name: \"Llama 4\",\n    provider: \"Meta\",\n  },\n  {\n    id: \"deepseek-v3\",\n    name: \"DeepSeek V3\",\n    provider: \"DeepSeek\",\n  },\n  {\n    id: \"grok-4\",\n    name: \"Grok\",\n    provider: \"xAI\",\n  },\n];\n\ninterface ModelSelectorProps {\n  selectedModel: LLMModel;\n  onSelectModel: (model: LLMModel) => void;\n}\n\nexport default function ModelSelector({\n  selectedModel,\n  onSelectModel,\n}: ModelSelectorProps) {\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <button className=\"flex items-center gap-2 px-3 py-1.5 bg-card hover:bg-accent/10 border border-border rounded-lg transition-colors text-sm\">\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-muted-foreground text-xs\">\n              {selectedModel.provider}\n            </span>\n            <span className=\"text-foreground font-medium text-xs\">\n              {selectedModel.name}\n            </span>\n          </div>\n          <ChevronDown className=\"w-3 h-3 text-muted-foreground\" />\n        </button>\n      </DropdownMenuTrigger>\n\n      <DropdownMenuContent\n        className=\"bg-card border-border\"\n        align=\"start\"\n        sideOffset={8}\n      >\n        <DropdownMenuLabel className=\"text-xs font-semibold text-muted-foreground\">\n          SELECT MODEL\n        </DropdownMenuLabel>\n\n        <DropdownMenuGroup>\n          {AVAILABLE_MODELS.map((model) => (\n            <DropdownMenuItem\n              key={model.id}\n              onClick={() => onSelectModel(model)}\n              className={`cursor-pointer ${\n                selectedModel.id === model.id\n                  ? \"text-foreground focus:text-foreground\"\n                  : \"text-muted-foreground\"\n              }`}\n            >\n              <div className=\"flex items-start justify-between gap-2 w-full\">\n                <div className=\"flex-1 min-w-0\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-sm font-medium truncate\">\n                      {model.name}\n                    </span>\n                    <span\n                      className={`text-xs px-1.5 py-0.5 rounded ${\n                        selectedModel.id === model.id\n                          ? \"bg-accent text-accent-foreground\"\n                          : \"bg-muted text-muted-foreground\"\n                      }`}\n                    >\n                      {model.provider}\n                    </span>\n                  </div>\n                </div>\n\n                {selectedModel.id === model.id && (\n                  <Check className=\"w-4 h-4 shrink-0 text-accent\" />\n                )}\n              </div>\n            </DropdownMenuItem>\n          ))}\n        </DropdownMenuGroup>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AAAA;AACA;AAHA;;;;AAmBO,MAAM,mBAA+B;IAC1C;QACE,IAAI;QACJ,MAAM;QACN,UAAU;IACZ;IACA;QACE,IAAI;QACJ,MAAM;QACN,UAAU;IACZ;IACA;QACE,IAAI;QACJ,MAAM;QACN,UAAU;IACZ;IACA;QACE,IAAI;QACJ,MAAM;QACN,UAAU;IACZ;IACA;QACE,IAAI;QACJ,MAAM;QACN,UAAU;IACZ;CACD;AAOc,SAAS,cAAc,EACpC,aAAa,EACb,aAAa,EACM;IACnB,qBACE,8OAAC,4JAAY;;0BACX,8OAAC,mKAAmB;gBAAC,OAAO;0BAC1B,cAAA,8OAAC;oBAAO,WAAU;;sCAChB,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAK,WAAU;8CACb,cAAc,QAAQ;;;;;;8CAEzB,8OAAC;oCAAK,WAAU;8CACb,cAAc,IAAI;;;;;;;;;;;;sCAGvB,8OAAC,mOAAW;4BAAC,WAAU;;;;;;;;;;;;;;;;;0BAI3B,8OAAC,mKAAmB;gBAClB,WAAU;gBACV,OAAM;gBACN,YAAY;;kCAEZ,8OAAC,iKAAiB;wBAAC,WAAU;kCAA8C;;;;;;kCAI3E,8OAAC,iKAAiB;kCACf,iBAAiB,GAAG,CAAC,CAAC,sBACrB,8OAAC,gKAAgB;gCAEf,SAAS,IAAM,cAAc;gCAC7B,WAAW,CAAC,eAAe,EACzB,cAAc,EAAE,KAAK,MAAM,EAAE,GACzB,0CACA,yBACJ;0CAEF,cAAA,8OAAC;oCAAI,WAAU;;sDACb,8OAAC;4CAAI,WAAU;sDACb,cAAA,8OAAC;gDAAI,WAAU;;kEACb,8OAAC;wDAAK,WAAU;kEACb,MAAM,IAAI;;;;;;kEAEb,8OAAC;wDACC,WAAW,CAAC,8BAA8B,EACxC,cAAc,EAAE,KAAK,MAAM,EAAE,GACzB,qCACA,kCACJ;kEAED,MAAM,QAAQ;;;;;;;;;;;;;;;;;wCAKpB,cAAc,EAAE,KAAK,MAAM,EAAE,kBAC5B,8OAAC,6MAAK;4CAAC,WAAU;;;;;;;;;;;;+BA3BhB,MAAM,EAAE;;;;;;;;;;;;;;;;;;;;;;AAoC3B"}},
    {"offset": {"line": 4192, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAggCsB,0BAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 4204, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAi6BsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 4216, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA2hCsB,gBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 4228, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA6lCsB,iCAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 4240, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAkkCsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 4252, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/chat-interface.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { useState, useEffect, useRef } from \"react\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\nimport MessageList from \"./message-list\";\nimport ChatInput from \"./chat-input\";\nimport AnswerPanel from \"./answer-panel\";\nimport ChatEmptyState from \"./chat-empty-state\";\nimport ModelSelector, { AVAILABLE_MODELS } from \"./model-selector\";\nimport VersionSelector from \"./version-selector\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  getConversationMessages,\n  createConversation,\n  createMessage,\n  getCodeSnippetsForConversation,\n  saveCodeSnippets,\n} from \"@/lib/services/repoService\";\nimport { CodeSnippet as DBCodeSnippet } from \"@/app/types/supabase\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\n\ninterface Message {\n  id: string;\n  text: string;\n  sender: \"user\" | \"assistant\";\n  timestamp: string;\n}\n\ninterface CodeSnippet {\n  file: string;\n  code: string;\n}\n\ninterface ConversationTurn {\n  id: number;\n  userQuestion: string;\n  timestamp: string;\n  codeSnippets: CodeSnippet[];\n  loading: boolean;\n}\n\nfunction MessageListSkeleton() {\n  return (\n    <div className=\"flex-1 overflow-y-auto px-6 py-4 space-y-8\">\n      {/* User message skeleton */}\n      <div className=\"mb-8 flex flex-row gap-6 px-5\">\n        <div className=\"flex-1 space-y-3\">\n          <Skeleton className=\"h-8 w-3/4\" />\n          <Skeleton className=\"h-8 w-full\" />\n        </div>\n        <Skeleton className=\"h-10 w-48 rounded-md\" />\n      </div>\n\n      {/* Assistant message skeleton */}\n      <div className=\"mb-8\">\n        <div className=\"mt-6\">\n          <div className=\"bg-elevated rounded-lg border border-gray-800 p-6\">\n            <div className=\"space-y-3\">\n              <Skeleton className=\"h-4 w-full\" />\n              <Skeleton className=\"h-4 w-full\" />\n              <Skeleton className=\"h-4 w-3/4\" />\n            </div>\n            <div className=\"flex gap-2 mt-4 pt-4 border-t border-gray-800\">\n              <Skeleton className=\"h-8 w-8 rounded-md\" />\n              <Skeleton className=\"h-8 w-8 rounded-md\" />\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* User message skeleton */}\n      <div className=\"mb-8 flex flex-row gap-6 px-5\">\n        <div className=\"flex-1 space-y-3\">\n          <Skeleton className=\"h-8 w-2/3\" />\n        </div>\n        <Skeleton className=\"h-10 w-48 rounded-md\" />\n      </div>\n    </div>\n  );\n}\n\nexport default function ChatInterface() {\n  const queryClient = useQueryClient();\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [conversationTurns, setConversationTurns] = useState<\n    ConversationTurn[]\n  >([]);\n  const [responseLoading, setResponseLoading] = useState<boolean>(false);\n  const [chatInputDisabled, setChatInputDisabled] = useState<boolean>(false);\n  const [inputValue, setInputValue] = useState(\"\");\n  const initialMessage = useChatUIStore((state) => state.initialMessage);\n  const selectedModel = useChatUIStore((state) => state.selectedModel);\n  const setSelectedModel = useChatUIStore((state) => state.setSelectedModel);\n  const conversation = useChatUIStore((state) => state.conversation);\n  const setConversation = useChatUIStore((state) => state.setConversation);\n  const repoId = useChatUIStore((state) => state.repoId);\n  const selectedVersion = useChatUIStore((state) => state.selectedVersion);\n  const hasSentInitialMessage = useRef(false);\n\n  // Fetch messages for selected conversation\n  const { data: conversationMessages, isLoading: messagesLoading } = useQuery({\n    queryKey: [\"messages\", conversation?.id],\n    queryFn: async () => {\n      if (!conversation?.id) return [];\n      const result = await getConversationMessages(conversation.id);\n      if (!result.success) throw new Error(result.error);\n      return result.data;\n    },\n    enabled: !!conversation?.id,\n    staleTime: 1000 * 60 * 5, // Cache for 5 minutes\n  });\n\n  // Fetch code snippets for selected conversation\n  const { data: conversationCodeSnippets, isLoading: snippetsLoading } =\n    useQuery({\n      queryKey: [\"codeSnippets\", conversation?.id],\n      queryFn: async () => {\n        if (!conversation?.id) return [];\n        const result = await getCodeSnippetsForConversation(conversation.id);\n        if (!result.success) throw new Error(result.error);\n        return result.data;\n      },\n      enabled: !!conversation?.id,\n      staleTime: 1000 * 60 * 5, // Cache for 5 minutes\n    });\n\n  const sendMessage = async (text: string) => {\n    if (chatInputDisabled || !text.trim()) return;\n\n    setChatInputDisabled(true);\n    setResponseLoading(true);\n    const userQuestion = text;\n    const timestamp = new Date().toLocaleTimeString(\"en-US\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    });\n\n    // If no conversation exists, create one\n    let currentConversation = conversation;\n    if (!currentConversation && repoId) {\n      const result = await createConversation(\n        repoId,\n        userQuestion,\n        selectedVersion,\n      );\n      if (result.success) {\n        currentConversation = result.data;\n        setConversation(currentConversation);\n\n        // Invalidate conversations query to refresh the list\n        queryClient.invalidateQueries({\n          queryKey: [\"conversations\", repoId, selectedVersion],\n        });\n      } else {\n        console.error(\"Failed to create conversation:\", result.error);\n        setChatInputDisabled(false);\n        setResponseLoading(false);\n        return;\n      }\n    }\n\n    // Save user message to database\n    if (currentConversation) {\n      const messageResult = await createMessage(\n        currentConversation.id,\n        \"user\",\n        userQuestion,\n      );\n      if (!messageResult.success) {\n        console.error(\"Failed to save user message:\", messageResult.error);\n      }\n    }\n\n    // Add user message to chat\n    setMessages((prevMessages) => [\n      ...prevMessages,\n      {\n        id: `temp-${Date.now()}`,\n        text: userQuestion,\n        sender: \"user\",\n        timestamp,\n      },\n    ]);\n\n    // Create a new conversation turn with loading state\n    const turnId = Date.now();\n    setConversationTurns((prevTurns) => [\n      ...prevTurns,\n      {\n        id: turnId,\n        userQuestion,\n        timestamp,\n        codeSnippets: [],\n        loading: true,\n      },\n    ]);\n\n    setInputValue(\"\");\n\n    try {\n      // Call the streaming API endpoint\n\n      const new_conversation: Message[] = [];\n      //start a new conversation\n      if (!conversationMessages) {\n      }\n      const response = await fetch(\"/api/chat\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          query: userQuestion,\n          model: selectedModel.name,\n          conversation: conversationMessages\n            ? conversationMessages\n            : new_conversation,\n          repoId,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`API error: ${response.statusText}`);\n      }\n\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n\n      // Handle the streaming response\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let accumulatedText = \"\";\n      let buffer = \"\"; // Buffer for incomplete SSE messages\n      const assistantMessageId = `temp-assistant-${Date.now()}`;\n      let firstContentReceived = false;\n      const codeSnippets: CodeSnippet[] = []; // Accumulate snippets from stream\n\n      // Read the stream\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          console.log(\"Stream done. Final accumulated text:\", accumulatedText);\n          break;\n        }\n\n        // Decode the chunk and add to buffer\n        const chunk = decoder.decode(value, { stream: true });\n        buffer += chunk;\n\n        // Process complete SSE messages (ending with \\n\\n)\n        const messages = buffer.split(\"\\n\\n\");\n\n        // Keep the last incomplete message in the buffer\n        buffer = messages.pop() || \"\";\n\n        for (const message of messages) {\n          if (!message.trim()) continue;\n\n          // Parse SSE format: \"data: {...}\"\n          if (message.startsWith(\"data: \")) {\n            const dataStr = message.slice(6).trim();\n\n            // Check for stream end\n            if (dataStr === \"[DONE]\") {\n              console.log(\"Received [DONE] signal\");\n              continue;\n            }\n\n            try {\n              const dataObj = JSON.parse(dataStr);\n\n              // Handle content events: {\"type\": \"content\", \"content\": \"...\"}\n              if (dataObj.type === \"content\" && dataObj.content) {\n                accumulatedText += dataObj.content;\n\n                // On first content, hide loading and create assistant message\n                if (!firstContentReceived) {\n                  firstContentReceived = true;\n                  setResponseLoading(false);\n\n                  setConversationTurns((prevTurns) =>\n                    prevTurns.map((turn) =>\n                      turn.id === turnId\n                        ? {\n                            ...turn,\n                            loading: false,\n                          }\n                        : turn,\n                    ),\n                  );\n\n                  setMessages((prevMessages) => [\n                    ...prevMessages,\n                    {\n                      id: assistantMessageId,\n                      text: accumulatedText,\n                      sender: \"assistant\",\n                      timestamp: new Date().toLocaleTimeString(\"en-US\", {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    },\n                  ]);\n                } else {\n                  // Update the assistant message with accumulated text\n                  setMessages((prevMessages) =>\n                    prevMessages.map((msg) =>\n                      msg.id === assistantMessageId\n                        ? { ...msg, text: accumulatedText }\n                        : msg,\n                    ),\n                  );\n                }\n              }\n              // Handle snippet events: {\"type\": \"snippet\", \"file\": \"...\", \"code\": \"...\"}\n              else if (\n                dataObj.type === \"snippet\" &&\n                dataObj.file &&\n                dataObj.code\n              ) {\n                const newSnippet: CodeSnippet = {\n                  file: dataObj.file,\n                  code: dataObj.code,\n                };\n                codeSnippets.push(newSnippet);\n\n                // Update conversation turn with new snippet in real-time\n                setConversationTurns((prevTurns) =>\n                  prevTurns.map((turn) =>\n                    turn.id === turnId\n                      ? {\n                          ...turn,\n                          codeSnippets: [...codeSnippets],\n                        }\n                      : turn,\n                  ),\n                );\n              }\n              // Fallback: Handle legacy format {\"content\": \"...\"} (no type field)\n              else if (\n                dataObj.content &&\n                typeof dataObj.content === \"string\" &&\n                !dataObj.type\n              ) {\n                accumulatedText += dataObj.content;\n\n                // On first content, hide loading and create assistant message\n                if (!firstContentReceived) {\n                  firstContentReceived = true;\n                  setResponseLoading(false);\n\n                  setConversationTurns((prevTurns) =>\n                    prevTurns.map((turn) =>\n                      turn.id === turnId\n                        ? {\n                            ...turn,\n                            loading: false,\n                          }\n                        : turn,\n                    ),\n                  );\n\n                  setMessages((prevMessages) => [\n                    ...prevMessages,\n                    {\n                      id: assistantMessageId,\n                      text: accumulatedText,\n                      sender: \"assistant\",\n                      timestamp: new Date().toLocaleTimeString(\"en-US\", {\n                        hour: \"2-digit\",\n                        minute: \"2-digit\",\n                      }),\n                    },\n                  ]);\n                } else {\n                  // Update the assistant message with accumulated text\n                  setMessages((prevMessages) =>\n                    prevMessages.map((msg) =>\n                      msg.id === assistantMessageId\n                        ? { ...msg, text: accumulatedText }\n                        : msg,\n                    ),\n                  );\n                }\n              }\n            } catch (e) {\n              console.warn(\"Failed to parse SSE data:\", dataStr, e);\n            }\n          }\n        }\n      }\n\n      // Save assistant message to database first to get the real message ID\n      let realMessageId = assistantMessageId;\n      if (currentConversation && accumulatedText) {\n        const assistantMessageResult = await createMessage(\n          currentConversation.id,\n          \"assistant\",\n          accumulatedText,\n        );\n        if (assistantMessageResult.success) {\n          realMessageId = assistantMessageResult.data.id;\n        } else {\n          console.error(\n            \"Failed to save assistant message:\",\n            assistantMessageResult.error,\n          );\n        }\n      }\n\n      // Save code snippets to database with the real message ID\n      if (currentConversation && codeSnippets.length > 0) {\n        const saveResult = await saveCodeSnippets(\n          currentConversation.id,\n          realMessageId,\n          codeSnippets,\n        );\n\n        if (saveResult.success) {\n          queryClient.invalidateQueries({\n            queryKey: [\"codeSnippets\", currentConversation.id],\n          });\n          queryClient.invalidateQueries({\n            queryKey: [\"messages\", currentConversation.id],\n          });\n        } else {\n          console.error(\"Failed to save code snippets:\", saveResult.error);\n        }\n      }\n\n      // Ensure final state is updated (in case no snippets were received)\n      setConversationTurns((prevTurns) =>\n        prevTurns.map((turn) =>\n          turn.id === turnId\n            ? {\n                ...turn,\n                loading: false,\n                codeSnippets: codeSnippets,\n              }\n            : turn,\n        ),\n      );\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n\n      // Add error message\n      setMessages((prevMessages) => [\n        ...prevMessages,\n        {\n          id: `temp-error-${Date.now()}`,\n          text: `Sorry, I encountered an error: ${error instanceof Error ? error.message : \"Unknown error\"}. Please try again.`,\n          sender: \"assistant\",\n          timestamp: new Date().toLocaleTimeString(\"en-US\", {\n            hour: \"2-digit\",\n            minute: \"2-digit\",\n          }),\n        },\n      ]);\n\n      // Update conversation turn to show error\n      setConversationTurns((prevTurns) =>\n        prevTurns.map((turn) =>\n          turn.id === turnId\n            ? {\n                ...turn,\n                loading: false,\n                codeSnippets: [],\n              }\n            : turn,\n        ),\n      );\n    } finally {\n      setResponseLoading(false);\n      setChatInputDisabled(false);\n    }\n  };\n\n  const handleSend = () => {\n    sendMessage(inputValue);\n  };\n\n  // Clear messages when conversation changes (including when set to null)\n  useEffect(() => {\n    setMessages([]);\n    setConversationTurns([]);\n  }, [conversation?.id]);\n\n  // Load conversation messages and code snippets when they're fetched\n  useEffect(() => {\n    // Wait for both queries to finish loading before building turns\n    if (messagesLoading || snippetsLoading) {\n      return;\n    }\n\n    if (conversationMessages && conversationMessages.length > 0) {\n      const loadedMessages: Message[] = conversationMessages.map((msg) => ({\n        id: msg.id,\n        text: msg.content,\n        sender: msg.role,\n        timestamp: new Date(msg.created_at).toLocaleTimeString(\"en-US\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n        }),\n      }));\n      setMessages(loadedMessages);\n\n      // Build conversation turns from loaded messages and snippets\n      const turns: ConversationTurn[] = [];\n\n      for (let i = 0; i < loadedMessages.length; i += 2) {\n        const userMsg = loadedMessages[i];\n        const assistantMsg = loadedMessages[i + 1];\n\n        if (userMsg && assistantMsg) {\n          // Find snippets for this assistant message\n          const snippetsForMsg = (conversationCodeSnippets || [])\n            .filter((snippet) => snippet.message_id === assistantMsg.id)\n            .map((snippet) => ({\n              file: snippet.file_path,\n              code: snippet.code_content,\n            }));\n\n          turns.push({\n            id: i / 2,\n            userQuestion: userMsg.text,\n            timestamp: userMsg.timestamp,\n            codeSnippets: snippetsForMsg,\n            loading: false,\n          });\n        }\n      }\n\n      setConversationTurns(turns);\n    }\n  }, [\n    conversationMessages,\n    conversationCodeSnippets,\n    messagesLoading,\n    snippetsLoading,\n  ]);\n\n  // Auto-send initial message when component mounts\n  useEffect(() => {\n    if (initialMessage && !hasSentInitialMessage.current) {\n      hasSentInitialMessage.current = true;\n      // Clear any existing conversation to start fresh\n      setConversation(null);\n      // Send the initial message\n      sendMessage(initialMessage);\n    }\n  }, [initialMessage, setConversation]);\n\n  // Show empty state when there are no messages and no initial message\n  const showEmptyState =\n    messages.length === 0 && !initialMessage && !conversation;\n\n  // Show loading state when fetching messages for a selected conversation\n  const showMessagesLoading = messagesLoading && !!conversation;\n\n  return (\n    <div className=\"flex h-[calc(100vh-64px)] bg-white dark:bg-background text-gray-900 dark:text-gray-300\">\n      {/* Chat Column */}\n      <div className=\"flex flex-col w-1/2 border-r border-gray-200 dark:border-gray-800\">\n        {/* Header with Model and Version Selectors */}\n        <div className=\"flex items-center justify-between px-6 py-4 border-b border-border\">\n          <div className=\"flex items-center gap-3\">\n            <ModelSelector\n              selectedModel={selectedModel}\n              onSelectModel={setSelectedModel}\n            />\n            <VersionSelector />\n          </div>\n        </div>\n\n        {showEmptyState ? (\n          <ChatEmptyState onSendMessage={sendMessage} />\n        ) : showMessagesLoading ? (\n          <MessageListSkeleton />\n        ) : (\n          <MessageList messages={messages} loading={responseLoading} />\n        )}\n        <ChatInput\n          value={inputValue}\n          onChange={setInputValue}\n          onSend={handleSend}\n          disabled={chatInputDisabled}\n        />\n      </div>\n\n      {/* Answers Column */}\n      <AnswerPanel conversationTurns={conversationTurns} />\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4907, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/chat/chat-overlay.tsx"],"sourcesContent":["\"use client\";\n\nimport React from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\nimport ChatInterface from \"./chat-interface\";\n\nexport default function ChatOverlay() {\n  const { isExpanded } = useChatUIStore();\n\n  return (\n    <AnimatePresence initial={false}>\n      {isExpanded && (\n        <div className=\"absolute inset-0 z-50 flex items-center justify-center\">\n          {/* Morphing chat container */}\n          <motion.div\n            layoutId=\"chat-container\"\n            transition={{ duration: 0.3 }}\n            style={{\n              borderRadius: 12,\n            }}\n            layout\n            className=\"relative flex h-full w-full overflow-y-auto transform-gpu will-change-transform bg-white dark:bg-background border border-border shadow-2xl\"\n          >\n            <motion.div\n              initial={{ opacity: 0 }}\n              animate={{ opacity: 1 }}\n              exit={{ opacity: 0 }}\n              transition={{ delay: 0.15, duration: 0.1 }}\n              className=\"relative z-20 w-full flex flex-col h-full\"\n            >\n              {/* Chat interface */}\n              <div className=\"flex-1 overflow-hidden px-2\">\n                <ChatInterface />\n              </div>\n            </motion.div>\n          </motion.div>\n        </div>\n      )}\n    </AnimatePresence>\n  );\n}\n"],"names":[],"mappings":";;;;;AAGA;AAAA;AACA;AACA;AALA;;;;;AAOe,SAAS;IACtB,MAAM,EAAE,UAAU,EAAE,GAAG,IAAA,wJAAc;IAErC,qBACE,8OAAC,4MAAe;QAAC,SAAS;kBACvB,4BACC,8OAAC;YAAI,WAAU;sBAEb,cAAA,8OAAC,oMAAM,CAAC,GAAG;gBACT,UAAS;gBACT,YAAY;oBAAE,UAAU;gBAAI;gBAC5B,OAAO;oBACL,cAAc;gBAChB;gBACA,MAAM;gBACN,WAAU;0BAEV,cAAA,8OAAC,oMAAM,CAAC,GAAG;oBACT,SAAS;wBAAE,SAAS;oBAAE;oBACtB,SAAS;wBAAE,SAAS;oBAAE;oBACtB,MAAM;wBAAE,SAAS;oBAAE;oBACnB,YAAY;wBAAE,OAAO;wBAAM,UAAU;oBAAI;oBACzC,WAAU;8BAGV,cAAA,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC,uKAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQ9B"}},
    {"offset": {"line": 4989, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/navbar-context-setter.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useNavBarStore } from \"@/lib/stores/useNavbarStore\";\n\ninterface NavbarContextSetterProps {\n  contextText?: string;\n  breadcrumbs?: Array<{ label: string; href?: string }>;\n  appendBreadcrumb?: { label: string; href?: string };\n}\n\n/**\n * Client component that sets the navbar context.\n * Use this in Server Components to update the navbar state.\n *\n * @param contextText - Simple text to display (no breadcrumbs)\n * @param breadcrumbs - Complete breadcrumb trail (replaces existing)\n * @param appendBreadcrumb - Single breadcrumb to append to existing trail\n */\nexport function NavbarContextSetter({\n  contextText,\n  breadcrumbs,\n  appendBreadcrumb,\n}: NavbarContextSetterProps) {\n  const setContext = useNavBarStore((state) => state.setContext);\n  const setBreadcrumbs = useNavBarStore((state) => state.setBreadcrumbs);\n  const appendBreadcrumbAction = useNavBarStore(\n    (state) => state.appendBreadcrumb,\n  );\n  const reset = useNavBarStore((state) => state.reset);\n\n  useEffect(() => {\n    if (breadcrumbs) {\n      setBreadcrumbs(breadcrumbs);\n    } else if (appendBreadcrumb) {\n      appendBreadcrumbAction(appendBreadcrumb);\n    } else if (contextText) {\n      setContext(contextText);\n    }\n\n    // Clean up on unmount\n    return () => {\n      reset();\n    };\n  }, [\n    contextText,\n    breadcrumbs,\n    appendBreadcrumb,\n    setContext,\n    setBreadcrumbs,\n    appendBreadcrumbAction,\n    reset,\n  ]);\n\n  // This component doesn't render anything\n  return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAmBO,SAAS,oBAAoB,EAClC,WAAW,EACX,WAAW,EACX,gBAAgB,EACS;IACzB,MAAM,aAAa,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,UAAU;IAC7D,MAAM,iBAAiB,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,cAAc;IACrE,MAAM,yBAAyB,IAAA,wJAAc,EAC3C,CAAC,QAAU,MAAM,gBAAgB;IAEnC,MAAM,QAAQ,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,KAAK;IAEnD,IAAA,kNAAS,EAAC;QACR,IAAI,aAAa;YACf,eAAe;QACjB,OAAO,IAAI,kBAAkB;YAC3B,uBAAuB;QACzB,OAAO,IAAI,aAAa;YACtB,WAAW;QACb;QAEA,sBAAsB;QACtB,OAAO;YACL;QACF;IACF,GAAG;QACD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,yCAAyC;IACzC,OAAO;AACT"}},
    {"offset": {"line": 5031, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/repo-context-setter.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useChatUIStore } from \"@/lib/stores/useChatUIStore\";\n\nexport function RepoContextSetter({\n  repoId,\n  version,\n}: {\n  repoId: string;\n  version: number | null;\n}) {\n  const setRepoId = useChatUIStore((state) => state.setRepoId);\n  const setSelectedVersion = useChatUIStore(\n    (state) => state.setSelectedVersion,\n  );\n  const reset = useChatUIStore((state) => state.reset);\n\n  useEffect(() => {\n    setRepoId(repoId);\n    setSelectedVersion(version);\n\n    // Cleanup when component unmounts (user navigates away)\n    return () => {\n      reset();\n    };\n  }, [repoId, version, setRepoId, setSelectedVersion, reset]);\n\n  return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAKO,SAAS,kBAAkB,EAChC,MAAM,EACN,OAAO,EAIR;IACC,MAAM,YAAY,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,SAAS;IAC3D,MAAM,qBAAqB,IAAA,wJAAc,EACvC,CAAC,QAAU,MAAM,kBAAkB;IAErC,MAAM,QAAQ,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,KAAK;IAEnD,IAAA,kNAAS,EAAC;QACR,UAAU;QACV,mBAAmB;QAEnB,wDAAwD;QACxD,OAAO;YACL;QACF;IACF,GAAG;QAAC;QAAQ;QAAS;QAAW;QAAoB;KAAM;IAE1D,OAAO;AACT"}}]
}