{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,yKAAmB;QAClB,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nfunction Card({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        \"bg-elevated text-card-foreground flex flex-col gap-6 rounded-md border py-6 shadow-sm\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CardHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        \"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CardTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-title\"\n      className={cn(\"leading-none font-semibold\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardDescription({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardAction({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        \"col-start-2 row-span-2 row-start-1 self-start justify-self-end\",\n        className,\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction CardContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-content\"\n      className={cn(\"px-6\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn(\"flex items-center px-6 [.border-t]:pt-6\", className)}\n      {...props}\n    />\n  );\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAEA;;;AAEA,SAAS,KAAK,EAAE,SAAS,EAAE,GAAG,OAAoC;IAChE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,yFACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,4JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAoC;IACrE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,gBAAgB,EAAE,SAAS,EAAE,GAAG,OAAoC;IAC3E,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,kEACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAoC;IACvE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,QAAQ;QACrB,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,2CAA2C;QACxD,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Dialog({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Root>) {\n  return <DialogPrimitive.Root data-slot=\"dialog\" {...props} />\n}\n\nfunction DialogTrigger({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {\n  return <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />\n}\n\nfunction DialogPortal({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Portal>) {\n  return <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />\n}\n\nfunction DialogClose({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Close>) {\n  return <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />\n}\n\nfunction DialogOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {\n  return (\n    <DialogPrimitive.Overlay\n      data-slot=\"dialog-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogContent({\n  className,\n  children,\n  showCloseButton = true,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Content> & {\n  showCloseButton?: boolean\n}) {\n  return (\n    <DialogPortal data-slot=\"dialog-portal\">\n      <DialogOverlay />\n      <DialogPrimitive.Content\n        data-slot=\"dialog-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n        {showCloseButton && (\n          <DialogPrimitive.Close\n            data-slot=\"dialog-close\"\n            className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\"\n          >\n            <XIcon />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        )}\n      </DialogPrimitive.Content>\n    </DialogPortal>\n  )\n}\n\nfunction DialogHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-header\"\n      className={cn(\"flex flex-col gap-2 text-center sm:text-left\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"dialog-footer\"\n      className={cn(\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Title>) {\n  return (\n    <DialogPrimitive.Title\n      data-slot=\"dialog-title\"\n      className={cn(\"text-lg leading-none font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Description>) {\n  return (\n    <DialogPrimitive.Description\n      data-slot=\"dialog-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,cAAc,EACrB,GAAG,OACkD;IACrD,qBAAO,8OAAC,6KAAuB;QAAC,aAAU;QAAkB,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,aAAa,EACpB,GAAG,OACiD;IACpD,qBAAO,8OAAC,4KAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,GAAG,OACkD;IACrD,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,kBAAkB,IAAI,EACtB,GAAG,OAGJ;IACC,qBACE,8OAAC;QAAa,aAAU;;0BACtB,8OAAC;;;;;0BACD,8OAAC,6KAAuB;gBACtB,aAAU;gBACV,WAAW,IAAA,yHAAE,EACX,+WACA;gBAED,GAAG,KAAK;;oBAER;oBACA,iCACC,8OAAC,2KAAqB;wBACpB,aAAU;wBACV,WAAU;;0CAEV,8OAAC,yMAAK;;;;;0CACN,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAMtC;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,0DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,iLAA2B;QAC1B,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA8ZsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAghBsB,aAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.installation_id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAwXsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 376, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/components/dashboard/navbar-context-setter.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useNavBarStore } from \"@/lib/stores/useNavbarStore\";\n\ninterface NavbarContextSetterProps {\n  contextText?: string;\n  breadcrumbs?: Array<{ label: string; href?: string }>;\n  appendBreadcrumb?: { label: string; href?: string };\n}\n\n/**\n * Client component that sets the navbar context.\n * Use this in Server Components to update the navbar state.\n *\n * @param contextText - Simple text to display (no breadcrumbs)\n * @param breadcrumbs - Complete breadcrumb trail (replaces existing)\n * @param appendBreadcrumb - Single breadcrumb to append to existing trail\n */\nexport function NavbarContextSetter({\n  contextText,\n  breadcrumbs,\n  appendBreadcrumb,\n}: NavbarContextSetterProps) {\n  const setContext = useNavBarStore((state) => state.setContext);\n  const setBreadcrumbs = useNavBarStore((state) => state.setBreadcrumbs);\n  const appendBreadcrumbAction = useNavBarStore(\n    (state) => state.appendBreadcrumb,\n  );\n  const reset = useNavBarStore((state) => state.reset);\n\n  useEffect(() => {\n    if (breadcrumbs) {\n      setBreadcrumbs(breadcrumbs);\n    } else if (appendBreadcrumb) {\n      appendBreadcrumbAction(appendBreadcrumb);\n    } else if (contextText) {\n      setContext(contextText);\n    }\n\n    // Clean up on unmount\n    return () => {\n      reset();\n    };\n  }, [\n    contextText,\n    breadcrumbs,\n    appendBreadcrumb,\n    setContext,\n    setBreadcrumbs,\n    appendBreadcrumbAction,\n    reset,\n  ]);\n\n  // This component doesn't render anything\n  return null;\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAmBO,SAAS,oBAAoB,EAClC,WAAW,EACX,WAAW,EACX,gBAAgB,EACS;IACzB,MAAM,aAAa,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,UAAU;IAC7D,MAAM,iBAAiB,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,cAAc;IACrE,MAAM,yBAAyB,IAAA,wJAAc,EAC3C,CAAC,QAAU,MAAM,gBAAgB;IAEnC,MAAM,QAAQ,IAAA,wJAAc,EAAC,CAAC,QAAU,MAAM,KAAK;IAEnD,IAAA,kNAAS,EAAC;QACR,IAAI,aAAa;YACf,eAAe;QACjB,OAAO,IAAI,kBAAkB;YAC3B,uBAAuB;QACzB,OAAO,IAAI,aAAa;YACtB,WAAW;QACb;QAEA,sBAAsB;QACtB,OAAO;YACL;QACF;IACF,GAAG;QACD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,yCAAyC;IACzC,OAAO;AACT"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/CodeCompass_DEMO_FALL2025/codecompass/src/app/dashboard/repo/%5Bid%5D/settings/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { useRouter, useParams } from \"next/navigation\";\nimport {\n  updateRepoSettings,\n  deleteRepo,\n  getRepoWithStatus,\n} from \"@/lib/services/repoService\";\nimport { NavbarContextSetter } from \"@/components/dashboard/navbar-context-setter\";\nimport { createClient } from \"@/utils/supabase/client\";\nimport type { Repo } from \"@/app/types/supabase\";\n\nexport default function RepoSettings() {\n  const [repoName, setRepoName] = useState(\"\");\n  const [repo, setRepo] = useState<Repo | null>(null);\n  const [orgName, setOrgName] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [showDeleteDialog, setShowDeleteDialog] = useState(false);\n  const [deleteConfirmationText, setDeleteConfirmationText] = useState(\"\");\n  const [repoUrl, setRepoUrl] = useState(\"\");\n  const [uploadedFile, setUploadedFile] = useState<File | null>(null);\n  const router = useRouter();\n  const params = useParams();\n  const repoId = params.id as string;\n  const supabase = createClient();\n\n  useEffect(() => {\n    const loadRepo = async () => {\n      setIsLoading(true);\n      const result = await getRepoWithStatus(repoId);\n\n      if (!result.success) {\n        setError(result.error);\n        setIsLoading(false);\n        return;\n      }\n\n      setRepo(result.data);\n      setRepoName(result.data.name);\n      setRepoUrl(result.data.repo_url || \"\");\n\n      // Fetch organization name for breadcrumbs\n      const { data: org } = await supabase\n        .from(\"organizations\")\n        .select(\"name\")\n        .eq(\"id\", result.data.organization_id)\n        .single();\n\n      if (org) {\n        setOrgName(org.name);\n      }\n\n      setIsLoading(false);\n    };\n\n    loadRepo();\n  }, [repoId, supabase]);\n\n  const handleSave = async () => {\n    if (!repoName.trim()) {\n      setError(\"Repository name cannot be empty\");\n      return;\n    }\n\n    setIsSaving(true);\n    setError(\"\");\n\n    const settings: { name: string; repo_url?: string; file?: File } = {\n      name: repoName,\n    };\n\n    // Add GitHub URL if changed\n    if (repo?.provider === \"github\" && repoUrl && repoUrl !== repo.repo_url) {\n      settings.repo_url = repoUrl;\n    }\n\n    // Add file if uploaded\n    if (repo?.provider === \"local\" && uploadedFile) {\n      settings.file = uploadedFile;\n    }\n\n    const result = await updateRepoSettings(repoId, settings);\n\n    if (!result.success) {\n      setError(result.error);\n      setIsSaving(false);\n      return;\n    }\n\n    setIsSaving(false);\n    router.push(`/dashboard/repo/${repoId}`);\n  };\n\n  const handleDeleteClick = () => {\n    setDeleteConfirmationText(\"\");\n    setShowDeleteDialog(true);\n  };\n\n  const handleDeleteConfirm = async () => {\n    setIsDeleting(true);\n    setError(\"\");\n\n    const result = await deleteRepo(repoId);\n\n    if (!result.success) {\n      setError(result.error);\n      setIsDeleting(false);\n      setShowDeleteDialog(false);\n      return;\n    }\n\n    router.push(`/dashboard/org/${result.data.organizationId}`);\n  };\n\n  return (\n    <div className=\"max-w-3xl mx-auto space-y-6 py-8 px-4\">\n      {repo && (\n        <NavbarContextSetter\n          breadcrumbs={[\n            { label: \"Organizations\", href: \"/dashboard/organizations\" },\n            {\n              label: orgName || \"Organization\",\n              href: `/dashboard/org/${repo.organization_id}`,\n            },\n            { label: repo.name, href: `/dashboard/repo/${repo.id}` },\n            { label: \"Settings\" },\n          ]}\n        />\n      )}\n\n      <div className=\"space-y-2\">\n        <h1 className=\"text-3xl font-bold tracking-tight\">\n          Repository Settings\n        </h1>\n        <p className=\"text-muted-foreground\">\n          Manage your repository configuration and source files\n        </p>\n      </div>\n\n      {error && (\n        <div className=\"p-4 bg-destructive/10 text-destructive rounded-lg border border-destructive/20\">\n          {error}\n        </div>\n      )}\n\n      <Card className=\"border-border/50\">\n        <CardHeader className=\"pb-4\">\n          <CardTitle className=\"text-xl\">Repository Details</CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          {/* Repository Name */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"repoName\" className=\"text-sm font-medium\">\n              Repository Name\n            </Label>\n            <Input\n              id=\"repoName\"\n              value={isLoading ? \"Loading...\" : repoName}\n              onChange={(e) => setRepoName(e.target.value)}\n              placeholder=\"Enter repository name\"\n              disabled={isSaving}\n              className=\"h-10\"\n            />\n          </div>\n\n          {/* GitHub Repository URL */}\n          {repo?.provider === \"github\" && (\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"repoUrl\" className=\"text-sm font-medium\">\n                Repository URL\n              </Label>\n              <Input\n                id=\"repoUrl\"\n                value={isLoading ? \"Loading...\" : repoUrl}\n                onChange={(e) => setRepoUrl(e.target.value)}\n                placeholder=\"https://github.com/owner/repo\"\n                disabled={isSaving}\n                className=\"h-10 font-mono text-sm\"\n              />\n              <p className=\"text-xs text-muted-foreground\">\n                To see changes, you must manually request indexing after this\n                change.\n              </p>\n            </div>\n          )}\n\n          {/* Local Repository File Upload */}\n          {repo?.provider === \"local\" && (\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"repoFile\" className=\"text-sm font-medium\">\n                Repository File\n              </Label>\n              <Input\n                id=\"repoFile\"\n                type=\"file\"\n                accept=\".zip,application/zip\"\n                onChange={(e) => setUploadedFile(e.target.files?.[0] || null)}\n                disabled={isSaving}\n                className=\"cursor-pointer file:cursor-pointer file:border file:border-input file:bg-background file:hover:bg-accent file:px-4 file:py-1.5 file:rounded-md file:mr-3 file:transition-colors file:text-sm\"\n              />\n              {uploadedFile && (\n                <p className=\"text-xs text-muted-foreground\">\n                  Selected: {uploadedFile.name} (\n                  {(uploadedFile.size / 1024 / 1024).toFixed(2)} MB)\n                </p>\n              )}\n              <p className=\"text-xs text-muted-foreground\">\n                To see changes, you must manually request indexing after this\n                change.\n              </p>\n            </div>\n          )}\n\n          <div className=\"pt-2\">\n            <Button\n              onClick={handleSave}\n              disabled={isSaving}\n              className=\"w-full sm:w-auto\"\n            >\n              {isSaving ? \"Saving...\" : \"Save Changes\"}\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Danger Zone */}\n      <Card className=\"border-destructive/50\">\n        <CardHeader className=\"pb-4\">\n          <CardTitle className=\"text-xl text-destructive\">\n            Danger Zone\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Delete Repository</Label>\n            <p className=\"text-sm text-muted-foreground\">\n              Once you delete a repository, there is no going back. Please be\n              certain.\n            </p>\n          </div>\n          <Button\n            variant=\"destructive\"\n            onClick={handleDeleteClick}\n            disabled={isDeleting}\n            className=\"w-full sm:w-auto\"\n          >\n            Delete Repository\n          </Button>\n        </CardContent>\n      </Card>\n\n      {/* Delete Confirmation Dialog */}\n      <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Delete Repository</DialogTitle>\n            <DialogDescription>\n              Are you sure you want to delete this repository? This action\n              cannot be undone. All documentation and chat history will be\n              permanently removed.\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4 py-4\">\n            <div className=\"space-y-2\">\n              <Label\n                htmlFor=\"deleteConfirmation\"\n                className=\"text-sm font-medium\"\n              >\n                Type <span className=\"font-mono font-semibold\">{repoName}</span>{\" \"}\n                to confirm\n              </Label>\n              <Input\n                id=\"deleteConfirmation\"\n                value={deleteConfirmationText}\n                onChange={(e) => setDeleteConfirmationText(e.target.value)}\n                placeholder={repoName}\n                disabled={isDeleting}\n                className=\"h-10\"\n              />\n            </div>\n          </div>\n          <DialogFooter>\n            <Button\n              variant=\"outline\"\n              onClick={() => setShowDeleteDialog(false)}\n              disabled={isDeleting}\n              className=\"w-full sm:w-auto\"\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"destructive\"\n              onClick={handleDeleteConfirm}\n              disabled={isDeleting || deleteConfirmationText !== repoName}\n              className=\"w-full sm:w-auto\"\n            >\n              {isDeleting ? \"Deleting...\" : \"Delete Repository\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AAAA;AAKA;AACA;AAtBA;;;;;;;;;;;;AAyBe,SAAS;IACtB,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IACzC,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,iNAAQ,EAAc;IAC9C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,iNAAQ,EAAC;IACnC,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAC;IAC3C,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IACzC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAC7C,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,iNAAQ,EAAC;IACzD,MAAM,CAAC,wBAAwB,0BAA0B,GAAG,IAAA,iNAAQ,EAAC;IACrE,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IACvC,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,iNAAQ,EAAc;IAC9D,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,SAAS,OAAO,EAAE;IACxB,MAAM,WAAW,IAAA,kJAAY;IAE7B,IAAA,kNAAS,EAAC;QACR,MAAM,WAAW;YACf,aAAa;YACb,MAAM,SAAS,MAAM,IAAA,mLAAiB,EAAC;YAEvC,IAAI,CAAC,OAAO,OAAO,EAAE;gBACnB,SAAS,OAAO,KAAK;gBACrB,aAAa;gBACb;YACF;YAEA,QAAQ,OAAO,IAAI;YACnB,YAAY,OAAO,IAAI,CAAC,IAAI;YAC5B,WAAW,OAAO,IAAI,CAAC,QAAQ,IAAI;YAEnC,0CAA0C;YAC1C,MAAM,EAAE,MAAM,GAAG,EAAE,GAAG,MAAM,SACzB,IAAI,CAAC,iBACL,MAAM,CAAC,QACP,EAAE,CAAC,MAAM,OAAO,IAAI,CAAC,eAAe,EACpC,MAAM;YAET,IAAI,KAAK;gBACP,WAAW,IAAI,IAAI;YACrB;YAEA,aAAa;QACf;QAEA;IACF,GAAG;QAAC;QAAQ;KAAS;IAErB,MAAM,aAAa;QACjB,IAAI,CAAC,SAAS,IAAI,IAAI;YACpB,SAAS;YACT;QACF;QAEA,YAAY;QACZ,SAAS;QAET,MAAM,WAA6D;YACjE,MAAM;QACR;QAEA,4BAA4B;QAC5B,IAAI,MAAM,aAAa,YAAY,WAAW,YAAY,KAAK,QAAQ,EAAE;YACvE,SAAS,QAAQ,GAAG;QACtB;QAEA,uBAAuB;QACvB,IAAI,MAAM,aAAa,WAAW,cAAc;YAC9C,SAAS,IAAI,GAAG;QAClB;QAEA,MAAM,SAAS,MAAM,IAAA,oLAAkB,EAAC,QAAQ;QAEhD,IAAI,CAAC,OAAO,OAAO,EAAE;YACnB,SAAS,OAAO,KAAK;YACrB,YAAY;YACZ;QACF;QAEA,YAAY;QACZ,OAAO,IAAI,CAAC,CAAC,gBAAgB,EAAE,QAAQ;IACzC;IAEA,MAAM,oBAAoB;QACxB,0BAA0B;QAC1B,oBAAoB;IACtB;IAEA,MAAM,sBAAsB;QAC1B,cAAc;QACd,SAAS;QAET,MAAM,SAAS,MAAM,IAAA,4KAAU,EAAC;QAEhC,IAAI,CAAC,OAAO,OAAO,EAAE;YACnB,SAAS,OAAO,KAAK;YACrB,cAAc;YACd,oBAAoB;YACpB;QACF;QAEA,OAAO,IAAI,CAAC,CAAC,eAAe,EAAE,OAAO,IAAI,CAAC,cAAc,EAAE;IAC5D;IAEA,qBACE,8OAAC;QAAI,WAAU;;YACZ,sBACC,8OAAC,qLAAmB;gBAClB,aAAa;oBACX;wBAAE,OAAO;wBAAiB,MAAM;oBAA2B;oBAC3D;wBACE,OAAO,WAAW;wBAClB,MAAM,CAAC,eAAe,EAAE,KAAK,eAAe,EAAE;oBAChD;oBACA;wBAAE,OAAO,KAAK,IAAI;wBAAE,MAAM,CAAC,gBAAgB,EAAE,KAAK,EAAE,EAAE;oBAAC;oBACvD;wBAAE,OAAO;oBAAW;iBACrB;;;;;;0BAIL,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAG,WAAU;kCAAoC;;;;;;kCAGlD,8OAAC;wBAAE,WAAU;kCAAwB;;;;;;;;;;;;YAKtC,uBACC,8OAAC;gBAAI,WAAU;0BACZ;;;;;;0BAIL,8OAAC,wIAAI;gBAAC,WAAU;;kCACd,8OAAC,8IAAU;wBAAC,WAAU;kCACpB,cAAA,8OAAC,6IAAS;4BAAC,WAAU;sCAAU;;;;;;;;;;;kCAEjC,8OAAC,+IAAW;wBAAC,WAAU;;0CAErB,8OAAC;gCAAI,WAAU;;kDACb,8OAAC,0IAAK;wCAAC,SAAQ;wCAAW,WAAU;kDAAsB;;;;;;kDAG1D,8OAAC,0IAAK;wCACJ,IAAG;wCACH,OAAO,YAAY,eAAe;wCAClC,UAAU,CAAC,IAAM,YAAY,EAAE,MAAM,CAAC,KAAK;wCAC3C,aAAY;wCACZ,UAAU;wCACV,WAAU;;;;;;;;;;;;4BAKb,MAAM,aAAa,0BAClB,8OAAC;gCAAI,WAAU;;kDACb,8OAAC,0IAAK;wCAAC,SAAQ;wCAAU,WAAU;kDAAsB;;;;;;kDAGzD,8OAAC,0IAAK;wCACJ,IAAG;wCACH,OAAO,YAAY,eAAe;wCAClC,UAAU,CAAC,IAAM,WAAW,EAAE,MAAM,CAAC,KAAK;wCAC1C,aAAY;wCACZ,UAAU;wCACV,WAAU;;;;;;kDAEZ,8OAAC;wCAAE,WAAU;kDAAgC;;;;;;;;;;;;4BAQhD,MAAM,aAAa,yBAClB,8OAAC;gCAAI,WAAU;;kDACb,8OAAC,0IAAK;wCAAC,SAAQ;wCAAW,WAAU;kDAAsB;;;;;;kDAG1D,8OAAC,0IAAK;wCACJ,IAAG;wCACH,MAAK;wCACL,QAAO;wCACP,UAAU,CAAC,IAAM,gBAAgB,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI;wCACxD,UAAU;wCACV,WAAU;;;;;;oCAEX,8BACC,8OAAC;wCAAE,WAAU;;4CAAgC;4CAChC,aAAa,IAAI;4CAAC;4CAC5B,CAAC,aAAa,IAAI,GAAG,OAAO,IAAI,EAAE,OAAO,CAAC;4CAAG;;;;;;;kDAGlD,8OAAC;wCAAE,WAAU;kDAAgC;;;;;;;;;;;;0CAOjD,8OAAC;gCAAI,WAAU;0CACb,cAAA,8OAAC,4IAAM;oCACL,SAAS;oCACT,UAAU;oCACV,WAAU;8CAET,WAAW,cAAc;;;;;;;;;;;;;;;;;;;;;;;0BAOlC,8OAAC,wIAAI;gBAAC,WAAU;;kCACd,8OAAC,8IAAU;wBAAC,WAAU;kCACpB,cAAA,8OAAC,6IAAS;4BAAC,WAAU;sCAA2B;;;;;;;;;;;kCAIlD,8OAAC,+IAAW;wBAAC,WAAU;;0CACrB,8OAAC;gCAAI,WAAU;;kDACb,8OAAC,0IAAK;wCAAC,WAAU;kDAAsB;;;;;;kDACvC,8OAAC;wCAAE,WAAU;kDAAgC;;;;;;;;;;;;0CAK/C,8OAAC,4IAAM;gCACL,SAAQ;gCACR,SAAS;gCACT,UAAU;gCACV,WAAU;0CACX;;;;;;;;;;;;;;;;;;0BAOL,8OAAC,4IAAM;gBAAC,MAAM;gBAAkB,cAAc;0BAC5C,cAAA,8OAAC,mJAAa;;sCACZ,8OAAC,kJAAY;;8CACX,8OAAC,iJAAW;8CAAC;;;;;;8CACb,8OAAC,uJAAiB;8CAAC;;;;;;;;;;;;sCAMrB,8OAAC;4BAAI,WAAU;sCACb,cAAA,8OAAC;gCAAI,WAAU;;kDACb,8OAAC,0IAAK;wCACJ,SAAQ;wCACR,WAAU;;4CACX;0DACM,8OAAC;gDAAK,WAAU;0DAA2B;;;;;;4CAAiB;4CAAI;;;;;;;kDAGvE,8OAAC,0IAAK;wCACJ,IAAG;wCACH,OAAO;wCACP,UAAU,CAAC,IAAM,0BAA0B,EAAE,MAAM,CAAC,KAAK;wCACzD,aAAa;wCACb,UAAU;wCACV,WAAU;;;;;;;;;;;;;;;;;sCAIhB,8OAAC,kJAAY;;8CACX,8OAAC,4IAAM;oCACL,SAAQ;oCACR,SAAS,IAAM,oBAAoB;oCACnC,UAAU;oCACV,WAAU;8CACX;;;;;;8CAGD,8OAAC,4IAAM;oCACL,SAAQ;oCACR,SAAS;oCACT,UAAU,cAAc,2BAA2B;oCACnD,WAAU;8CAET,aAAa,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAO5C"}}]
}