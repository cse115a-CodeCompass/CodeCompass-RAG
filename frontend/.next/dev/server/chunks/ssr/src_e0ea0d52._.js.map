{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,yKAAmB;QAClB,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/ui/field.tsx"],"sourcesContent":["\"use client\"\n\nimport { useMemo } from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\nimport { Separator } from \"@/components/ui/separator\"\n\nfunction FieldSet({ className, ...props }: React.ComponentProps<\"fieldset\">) {\n  return (\n    <fieldset\n      data-slot=\"field-set\"\n      className={cn(\n        \"flex flex-col gap-6\",\n        \"has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldLegend({\n  className,\n  variant = \"legend\",\n  ...props\n}: React.ComponentProps<\"legend\"> & { variant?: \"legend\" | \"label\" }) {\n  return (\n    <legend\n      data-slot=\"field-legend\"\n      data-variant={variant}\n      className={cn(\n        \"mb-3 font-medium\",\n        \"data-[variant=legend]:text-base\",\n        \"data-[variant=label]:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"field-group\"\n      className={cn(\n        \"group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nconst fieldVariants = cva(\n  \"group/field flex w-full gap-3 data-[invalid=true]:text-destructive\",\n  {\n    variants: {\n      orientation: {\n        vertical: [\"flex-col [&>*]:w-full [&>.sr-only]:w-auto\"],\n        horizontal: [\n          \"flex-row items-center\",\n          \"[&>[data-slot=field-label]]:flex-auto\",\n          \"has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px\",\n        ],\n        responsive: [\n          \"flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto\",\n          \"@md/field-group:[&>[data-slot=field-label]]:flex-auto\",\n          \"@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px\",\n        ],\n      },\n    },\n    defaultVariants: {\n      orientation: \"vertical\",\n    },\n  }\n)\n\nfunction Field({\n  className,\n  orientation = \"vertical\",\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof fieldVariants>) {\n  return (\n    <div\n      role=\"group\"\n      data-slot=\"field\"\n      data-orientation={orientation}\n      className={cn(fieldVariants({ orientation }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction FieldContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"field-content\"\n      className={cn(\n        \"group/field-content flex flex-1 flex-col gap-1.5 leading-snug\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof Label>) {\n  return (\n    <Label\n      data-slot=\"field-label\"\n      className={cn(\n        \"group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50\",\n        \"has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4\",\n        \"has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"field-label\"\n      className={cn(\n        \"flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldDescription({ className, ...props }: React.ComponentProps<\"p\">) {\n  return (\n    <p\n      data-slot=\"field-description\"\n      className={cn(\n        \"text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance\",\n        \"last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5\",\n        \"[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldSeparator({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  children?: React.ReactNode\n}) {\n  return (\n    <div\n      data-slot=\"field-separator\"\n      data-content={!!children}\n      className={cn(\n        \"relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2\",\n        className\n      )}\n      {...props}\n    >\n      <Separator className=\"absolute inset-0 top-1/2\" />\n      {children && (\n        <span\n          className=\"bg-background text-muted-foreground relative mx-auto block w-fit px-2\"\n          data-slot=\"field-separator-content\"\n        >\n          {children}\n        </span>\n      )}\n    </div>\n  )\n}\n\nfunction FieldError({\n  className,\n  children,\n  errors,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  errors?: Array<{ message?: string } | undefined>\n}) {\n  const content = useMemo(() => {\n    if (children) {\n      return children\n    }\n\n    if (!errors?.length) {\n      return null\n    }\n\n    if (errors?.length == 1) {\n      return errors[0]?.message\n    }\n\n    return (\n      <ul className=\"ml-4 flex list-disc flex-col gap-1\">\n        {errors.map(\n          (error, index) =>\n            error?.message && <li key={index}>{error.message}</li>\n        )}\n      </ul>\n    )\n  }, [children, errors])\n\n  if (!content) {\n    return null\n  }\n\n  return (\n    <div\n      role=\"alert\"\n      data-slot=\"field-error\"\n      className={cn(\"text-destructive text-sm font-normal\", className)}\n      {...props}\n    >\n      {content}\n    </div>\n  )\n}\n\nexport {\n  Field,\n  FieldLabel,\n  FieldDescription,\n  FieldError,\n  FieldGroup,\n  FieldLegend,\n  FieldSeparator,\n  FieldSet,\n  FieldContent,\n  FieldTitle,\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/ui/select.tsx"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport * as SelectPrimitive from \"@radix-ui/react-select\";\nimport { CheckIcon, ChevronDownIcon, ChevronUpIcon } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\n\nfunction Select({\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Root>) {\n  return <SelectPrimitive.Root data-slot=\"select\" {...props} />;\n}\n\nfunction SelectGroup({\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Group>) {\n  return <SelectPrimitive.Group data-slot=\"select-group\" {...props} />;\n}\n\nfunction SelectValue({\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Value>) {\n  return <SelectPrimitive.Value data-slot=\"select-value\" {...props} />;\n}\n\nfunction SelectTrigger({\n  className,\n  size = \"default\",\n  children,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {\n  size?: \"sm\" | \"default\";\n}) {\n  return (\n    <SelectPrimitive.Trigger\n      data-slot=\"select-trigger\"\n      data-size={size}\n      className={cn(\n        \"border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      {...props}\n    >\n      {children}\n      <SelectPrimitive.Icon asChild>\n        <ChevronDownIcon className=\"size-4 opacity-50\" />\n      </SelectPrimitive.Icon>\n    </SelectPrimitive.Trigger>\n  );\n}\n\nfunction SelectContent({\n  className,\n  children,\n  position = \"popper\",\n  align = \"center\",\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Content>) {\n  return (\n    <SelectPrimitive.Portal>\n      <SelectPrimitive.Content\n        data-slot=\"select-content\"\n        className={cn(\n          \"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md\",\n          position === \"popper\" &&\n            \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n          className,\n        )}\n        position={position}\n        align={align}\n        {...props}\n      >\n        <SelectScrollUpButton />\n        <SelectPrimitive.Viewport\n          className={cn(\n            \"p-1\",\n            position === \"popper\" &&\n              \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1\",\n          )}\n        >\n          {children}\n        </SelectPrimitive.Viewport>\n        <SelectScrollDownButton />\n      </SelectPrimitive.Content>\n    </SelectPrimitive.Portal>\n  );\n}\n\nfunction SelectLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Label>) {\n  return (\n    <SelectPrimitive.Label\n      data-slot=\"select-label\"\n      className={cn(\"text-muted-foreground px-2 py-1.5 text-xs\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction SelectItem({\n  className,\n  children,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Item>) {\n  return (\n    <SelectPrimitive.Item\n      data-slot=\"select-item\"\n      className={cn(\n        \"focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2\",\n        className,\n      )}\n      {...props}\n    >\n      <span className=\"absolute right-2 flex size-3.5 items-center justify-center\">\n        <SelectPrimitive.ItemIndicator>\n          <CheckIcon className=\"size-4\" />\n        </SelectPrimitive.ItemIndicator>\n      </span>\n      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n    </SelectPrimitive.Item>\n  );\n}\n\nfunction SelectSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Separator>) {\n  return (\n    <SelectPrimitive.Separator\n      data-slot=\"select-separator\"\n      className={cn(\"bg-border pointer-events-none -mx-1 my-1 h-px\", className)}\n      {...props}\n    />\n  );\n}\n\nfunction SelectScrollUpButton({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {\n  return (\n    <SelectPrimitive.ScrollUpButton\n      data-slot=\"select-scroll-up-button\"\n      className={cn(\n        \"flex cursor-default items-center justify-center py-1\",\n        className,\n      )}\n      {...props}\n    >\n      <ChevronUpIcon className=\"size-4\" />\n    </SelectPrimitive.ScrollUpButton>\n  );\n}\n\nfunction SelectScrollDownButton({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {\n  return (\n    <SelectPrimitive.ScrollDownButton\n      data-slot=\"select-scroll-down-button\"\n      className={cn(\n        \"flex cursor-default items-center justify-center py-1\",\n        className,\n      )}\n      {...props}\n    >\n      <ChevronDownIcon className=\"size-4\" />\n    </SelectPrimitive.ScrollDownButton>\n  );\n}\n\nexport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectLabel,\n  SelectScrollDownButton,\n  SelectScrollUpButton,\n  SelectSeparator,\n  SelectTrigger,\n  SelectValue,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,OAAO,SAAS,EAChB,QAAQ,EACR,GAAG,OAGJ;IACC,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,aAAW;QACX,WAAW,IAAA,yHAAE,EACX,gzBACA;QAED,GAAG,KAAK;;YAER;0BACD,8OAAC,0KAAoB;gBAAC,OAAO;0BAC3B,cAAA,8OAAC,2OAAe;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAInC;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,WAAW,QAAQ,EACnB,QAAQ,QAAQ,EAChB,GAAG,OACkD;IACrD,qBACE,8OAAC,4KAAsB;kBACrB,cAAA,8OAAC,6KAAuB;YACtB,aAAU;YACV,WAAW,IAAA,yHAAE,EACX,ijBACA,aAAa,YACX,mIACF;YAEF,UAAU;YACV,OAAO;YACN,GAAG,KAAK;;8BAET,8OAAC;;;;;8BACD,8OAAC,8KAAwB;oBACvB,WAAW,IAAA,yHAAE,EACX,OACA,aAAa,YACX;8BAGH;;;;;;8BAEH,8OAAC;;;;;;;;;;;;;;;;AAIT;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,6CAA6C;QAC1D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAClB,SAAS,EACT,QAAQ,EACR,GAAG,OAC+C;IAClD,qBACE,8OAAC,0KAAoB;QACnB,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,6aACA;QAED,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,mLAA6B;8BAC5B,cAAA,8OAAC,qNAAS;wBAAC,WAAU;;;;;;;;;;;;;;;;0BAGzB,8OAAC,8KAAwB;0BAAE;;;;;;;;;;;;AAGjC;AAEA,SAAS,gBAAgB,EACvB,SAAS,EACT,GAAG,OACoD;IACvD,qBACE,8OAAC,+KAAyB;QACxB,aAAU;QACV,WAAW,IAAA,yHAAE,EAAC,iDAAiD;QAC9D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,qBAAqB,EAC5B,SAAS,EACT,GAAG,OACyD;IAC5D,qBACE,8OAAC,oLAA8B;QAC7B,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,qOAAa;YAAC,WAAU;;;;;;;;;;;AAG/B;AAEA,SAAS,uBAAuB,EAC9B,SAAS,EACT,GAAG,OAC2D;IAC9D,qBACE,8OAAC,sLAAgC;QAC/B,aAAU;QACV,WAAW,IAAA,yHAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,2OAAe;YAAC,WAAU;;;;;;;;;;;AAGjC"}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IAoHsB,sBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 531, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA4LsB,sBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/lib/services/repoService.ts"],"sourcesContent":["\"use server\";\n\nimport { createClient } from \"@/utils/supabase/server\";\nimport {\n  Repo,\n  Documentation,\n  DocPage,\n  Conversation,\n  ConversationMessage,\n  CodeSnippet,\n} from \"@/app/types/supabase\";\nimport { ActionResult } from \"@/app/types/action\";\nimport {\n  verifyGithubRepoAccess,\n  verifyGitLabRepoAccess,\n} from \"./gitProviderService\";\n\n// Helper function to parse GitHub URLs\nfunction parseGitHubUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://github.com/owner/repo\n    // - https://github.com/owner/repo.git\n    // - git@github.com:owner/repo.git\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    if (url.includes(\"github.com/\")) {\n      const parts = url.split(\"github.com/\")[1].split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    if (url.startsWith(\"git@github.com:\")) {\n      const parts = url.replace(\"git@github.com:\", \"\").split(\"/\");\n      return { owner: parts[0], repo: parts[1] };\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\n// Helper function to parse GitLab URLs\nfunction parseGitLabUrl(url: string): { owner: string; repo: string } {\n  try {\n    // Handle multiple formats:\n    // - https://gitlab.com/owner/repo\n    // - https://gitlab.com/owner/subgroup/repo\n    // - https://gitlab.com/owner/repo.git\n    // - git@gitlab.com:owner/repo.git\n    // - Self-hosted: https://gitlab.example.com/owner/repo\n\n    url = url.trim().replace(/\\.git$/, \"\");\n\n    // Handle HTTPS URLs (gitlab.com or self-hosted)\n    if (url.includes(\"gitlab.com/\") || /gitlab\\.[^/]+\\//.test(url)) {\n      // Extract the path after the domain\n      const match = url.match(/gitlab[^/]*\\/(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        // GitLab supports nested groups, so we need to handle:\n        // - owner/repo (2 parts)\n        // - owner/subgroup/repo (3+ parts)\n        if (pathParts.length >= 2) {\n          // Take everything except the last part as owner/group\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    // Handle SSH URLs\n    if (url.startsWith(\"git@gitlab.com:\") || /git@gitlab\\.[^:]+:/.test(url)) {\n      const match = url.match(/git@gitlab[^:]*:(.+)/);\n      if (match) {\n        const pathParts = match[1].split(\"/\");\n        if (pathParts.length >= 2) {\n          const repo = pathParts[pathParts.length - 1];\n          const owner = pathParts.slice(0, -1).join(\"/\");\n          return { owner, repo };\n        }\n      }\n    }\n\n    return { owner: \"\", repo: \"\" };\n  } catch (error) {\n    return { owner: \"\", repo: \"\" };\n  }\n}\n\nexport async function getReposByOrganizationId(\n  organizationId: string,\n): Promise<ActionResult<Repo[]>> {\n  const client = await createClient();\n\n  const user = client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"organization_id\", organizationId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (data ?? []) as Repo[] };\n}\n\nexport async function createRepoViaGithub(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"github-url\") as string;\n\n  if (!name) {\n    return { success: false, error: \"Name is required!\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    // No GitHub App installation - prompt user to install\n    return {\n      success: false,\n      error: \"Installation Needed\",\n    };\n  }\n\n  //parse url for owner and repo\n  const { owner, repo: repoName } = parseGitHubUrl(url);\n\n  const hasAccess = await verifyGithubRepoAccess(\n    installation.id,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    return {\n      success: false,\n      error: \"Access Denied\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function createRepoViaGitlab(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo | undefined>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const provider = formData.get(\"type\") as string;\n  const url = formData.get(\"gitlab-url\") as string;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!url || url.trim() === \"\") {\n    return { success: false, error: \"GitLab URL is required\" };\n  }\n\n  const { data: installation } = await client\n    .from(\"gitlab_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation) {\n    return { success: false, error: \"Installation Needed\" };\n  }\n\n  const { owner, repo: repoName } = parseGitLabUrl(url);\n\n  //verify access\n  const hasAccess = await verifyGitLabRepoAccess(\n    installation.access_token,\n    owner,\n    repoName,\n  );\n\n  if (!hasAccess) {\n    if (installation.access_token) {\n      return {\n        success: false,\n        error: \"Access required!\",\n      };\n    }\n\n    return {\n      success: false,\n      error: \"Access denied!\",\n    };\n  }\n\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .insert({\n      name,\n      provider,\n      repo_url: url,\n      organization_id: orgId,\n      indexed_by: user.id,\n      index_status: \"not indexed\",\n    })\n    .select()\n    .single();\n\n  if (repoError) {\n    return { success: false, error: repoError.message };\n  }\n\n  return { success: true, data: repo };\n}\n\nexport async function createRepoViaLocalFile(\n  formData: FormData,\n  orgId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const name = formData.get(\"name\") as string;\n  const file = formData.get(\"file\") as File;\n\n  // Validate inputs\n  if (!name || name.trim() === \"\") {\n    return { success: false, error: \"Repository name is required\" };\n  }\n\n  if (!file) {\n    return { success: false, error: \"File is required\" };\n  }\n\n  // Validate file type\n  if (!file.name.endsWith(\".zip\")) {\n    return { success: false, error: \"Only .zip files are allowed\" };\n  }\n\n  // Validate file size (max 100MB)\n  const maxSize = 100 * 1024 * 1024; // 100MB in bytes\n  if (file.size > maxSize) {\n    return {\n      success: false,\n      error: \"File size exceeds 100MB limit\",\n    };\n  }\n\n  try {\n    // Generate a unique file name to prevent collisions\n    const timestamp = Date.now();\n    const sanitizedName = name.trim().replace(/[^a-z0-9-_]/gi, \"_\");\n    const fileName = `${sanitizedName}_${timestamp}_${file.name}`;\n    const filePath = `${orgId}/${fileName}`;\n\n    // Upload file to Supabase Storage\n    const { error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(filePath, file, {\n        contentType: \"application/zip\",\n        upsert: false,\n      });\n\n    if (uploadError) {\n      console.error(\"Upload error:\", uploadError);\n      return {\n        success: false,\n        error: `File upload failed: ${uploadError.message}`,\n      };\n    }\n\n    // Get the public URL for the uploaded file\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(filePath);\n\n    // Create repository record in database\n    const { data: repo, error: repoError } = await client\n      .from(\"repositories\")\n      .insert({\n        name: name.trim(),\n        provider: \"local\",\n        repo_url: null,\n        object_url: urlData.publicUrl,\n        organization_id: orgId,\n        indexed_by: user.id,\n        index_status: \"not indexed\",\n      })\n      .select()\n      .single();\n\n    if (repoError) {\n      console.error(\"Repository creation error:\", repoError);\n      // Attempt to clean up uploaded file\n      await client.storage.from(\"local_repos\").remove([filePath]);\n      return {\n        success: false,\n        error: `Repository creation failed: ${repoError.message}`,\n      };\n    }\n\n    return { success: true, data: repo as Repo };\n  } catch (error) {\n    console.error(\"Unexpected error:\", error);\n    return {\n      success: false,\n      error:\n        error instanceof Error ? error.message : \"An unexpected error occurred\",\n    };\n  }\n}\n\n// ============================================================================\n// Repository Management Services\n// ============================================================================\n\nexport async function getRepoWithStatus(\n  repoId: string,\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\ntype UpdateData = {\n  name?: string;\n  repo_url?: string;\n  object_url?: string;\n  index_status?: string;\n};\n\nexport async function updateRepoSettings(\n  repoId: string,\n  settings: { name?: string; repo_url?: string; file?: File },\n): Promise<ActionResult<Repo>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the current repo to check its provider type\n  const { data: currentRepo } = await client\n    .from(\"repositories\")\n    .select(\"*\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (!currentRepo) {\n    return { success: false, error: \"Repository not found!\" };\n  }\n\n  const updateData: UpdateData = {};\n\n  // Handle name update\n  if (settings.name) {\n    updateData.name = settings.name;\n  }\n\n  // Handle GitHub URL update\n  if (settings.repo_url && currentRepo.provider === \"github\") {\n    const { owner, repo } = parseGitHubUrl(settings.repo_url);\n\n    if (!owner || !repo) {\n      return { success: false, error: \"Invalid GitHub URL format!\" };\n    }\n\n    // Verify access to the new repo\n    const { data: installation } = await client\n      .from(\"github_installations\")\n      .select(\"*\")\n      .eq(\"installed_by\", user.id)\n      .single();\n\n    if (!installation) {\n      return { success: false, error: \"GitHub App not installed!\" };\n    }\n\n    const hasAccess = await verifyGithubRepoAccess(\n      installation.installation_id.toString(),\n      owner,\n      repo,\n    );\n\n    if (!hasAccess) {\n      return {\n        success: false,\n        error:\n          \"Cannot access this repository. Make sure the GitHub App is installed for this repository.\",\n      };\n    }\n\n    updateData.repo_url = settings.repo_url;\n    updateData.index_status = \"not indexed\"; // Trigger re-indexing\n  }\n\n  // Handle local file upload\n  if (settings.file && currentRepo.provider === \"local\") {\n    const file = settings.file;\n    const fileExt = file.name.split(\".\").pop();\n\n    if (fileExt !== \"zip\") {\n      return { success: false, error: \"Only .zip files are allowed!\" };\n    }\n\n    // Upload to Supabase Storage\n    const fileName = `${repoId}-${Date.now()}.zip`;\n    const { data: uploadData, error: uploadError } = await client.storage\n      .from(\"local_repos\")\n      .upload(fileName, file);\n\n    if (uploadError) {\n      console.error(uploadError);\n      return { success: false, error: \"Failed to upload file!\" };\n    }\n\n    // Get public URL\n    const { data: urlData } = client.storage\n      .from(\"local_repos\")\n      .getPublicUrl(fileName);\n\n    updateData.object_url = urlData.publicUrl;\n    updateData.index_status = \"pending\"; // Trigger re-indexing\n  }\n\n  // Update the repository\n  const { data: repo, error } = await client\n    .from(\"repositories\")\n    .update(updateData)\n    .eq(\"id\", repoId)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: repo as Repo };\n}\n\nexport async function deleteRepo(\n  repoId: string,\n): Promise<ActionResult<{ organizationId: string }>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Fetch the organization_id before deleting\n  const { data: repo, error: repoError } = await client\n    .from(\"repositories\")\n    .select(\"organization_id\")\n    .eq(\"id\", repoId)\n    .single();\n\n  if (repoError) {\n    console.error(repoError);\n    return { success: false, error: repoError.message };\n  }\n\n  if (!repo) {\n    return { success: false, error: \"Repository not found\" };\n  }\n\n  const { error } = await client.from(\"repositories\").delete().eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: { organizationId: repo.organization_id } };\n}\n\nexport async function triggerReindex(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Update the index_status to 'pending' to trigger reindexing\n  const { error } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"pending\" })\n    .eq(\"id\", repoId);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // TODO: Trigger actual indexing job/webhook/queue here\n  // This could be an API call to your indexing service\n\n  return { success: true, data: undefined };\n}\n\n// ============================================================================\n// Documentation Services\n// ============================================================================\n\nexport async function getDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\nexport async function getDocPages(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the latest documentation version for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\nexport async function getDocPageById(\n  pageId: string,\n): Promise<ActionResult<DocPage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: page, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"id\", pageId)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!page) {\n    return { success: false, error: \"Page not found\" };\n  }\n\n  return { success: true, data: page as DocPage };\n}\n\nexport async function getDocPagesHierarchical(\n  repoId: string,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // First get the documentation ID for this repo\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .single();\n\n  if (docError || !documentation) {\n    console.error(docError);\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"doc_pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Pages are already sorted by order_index\n  // The parent_page_id field maintains the hierarchy\n  // Frontend can use this to render the tree structure\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n/**\n * Get all documentation versions for a repository\n */\nexport async function getDocumentationVersions(\n  repoId: string,\n): Promise<ActionResult<Documentation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: versions, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (versions ?? []) as Documentation[] };\n}\n\n/**\n * Get the latest completed documentation version for a repository\n */\nexport async function getLatestDocumentation(\n  repoId: string,\n): Promise<ActionResult<Documentation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: documentation, error } = await client\n    .from(\"documentation\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  if (!documentation) {\n    return { success: false, error: \"Documentation not found\" };\n  }\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: documentation as Documentation };\n}\n\n/**\n * Get documentation pages for a specific version\n */\nexport async function getDocPagesForVersion(\n  repoId: string,\n  version: number,\n): Promise<ActionResult<DocPage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  // Get the documentation record for this version\n  const { data: documentation, error: docError } = await client\n    .from(\"documentation\")\n    .select(\"id\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"version\", version)\n    .single();\n\n  if (docError || !documentation) {\n    return { success: false, error: \"Documentation version not found\" };\n  }\n\n  const { data: pages, error } = await client\n    .from(\"pages\")\n    .select(\"*\")\n    .eq(\"documentation_id\", documentation.id)\n    .order(\"order_index\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (pages ?? []) as DocPage[] };\n}\n\n// ============================================================================\n// Conversation Services\n// ============================================================================\n\nexport async function getConversations(\n  repoId: string,\n  limit: number = 20,\n  version: number | null = null,\n): Promise<ActionResult<Conversation[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  let query = client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"repo_id\", repoId)\n    .eq(\"user_id\", user.id);\n\n  // Filter by version if specified\n  if (version !== null && version !== undefined) {\n    query = query.eq(\"repo_version\", version);\n  }\n\n  const { data: conversations, error } = await query\n    .order(\"updated_at\", { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (conversations ?? []) as Conversation[] };\n}\n\nexport async function getConversationById(\n  conversationId: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .select(\"*\")\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  if (!conversation) {\n    return { success: false, error: \"Conversation not found\" };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function createConversation(\n  repoId: string,\n  title?: string,\n  version?: number | null,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .insert({\n      repo_id: repoId,\n      user_id: user.id,\n      title: title || \"New Conversation\",\n      repo_version: version ?? null,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\nexport async function deleteConversation(\n  conversationId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { error } = await client\n    .from(\"conversations\")\n    .delete()\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: undefined };\n}\n\nexport async function renameConversation(\n  conversationId: string,\n  newTitle: string,\n): Promise<ActionResult<Conversation>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: conversation, error } = await client\n    .from(\"conversations\")\n    .update({ title: newTitle })\n    .eq(\"id\", conversationId)\n    .eq(\"user_id\", user.id)\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: conversation as Conversation };\n}\n\n// ============================================================================\n// Message Services\n// ============================================================================\n\nexport async function getConversationMessages(\n  conversationId: string,\n): Promise<ActionResult<ConversationMessage[]>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: messages, error } = await client\n    .from(\"messages\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: true });\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: (messages ?? []) as ConversationMessage[] };\n}\n\nexport async function createMessage(\n  conversationId: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n): Promise<ActionResult<ConversationMessage>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: message, error } = await client\n    .from(\"messages\")\n    .insert({\n      conversation_id: conversationId,\n      role,\n      content,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    console.error(error);\n    return { success: false, error: error.message };\n  }\n\n  // Update the conversation's updated_at timestamp\n  await client\n    .from(\"conversations\")\n    .update({ updated_at: new Date().toISOString() })\n    .eq(\"id\", conversationId);\n\n  return { success: true, data: message as ConversationMessage };\n}\n\nexport async function saveCodeSnippets(\n  conversationId: string,\n  messageId: string,\n  snippets: Array<{ file: string; code: string }>,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const snippetsToInsert = snippets.map((snippet) => ({\n    conversation_id: conversationId,\n    message_id: messageId,\n    file_path: snippet.file,\n    code_content: snippet.code,\n    language: snippet.file.split(\".\").pop() || null,\n  }));\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .insert(snippetsToInsert)\n    .select();\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function getCodeSnippetsForConversation(\n  conversationId: string,\n): Promise<ActionResult<CodeSnippet[]>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from(\"code_snippets\")\n    .select(\"*\")\n    .eq(\"conversation_id\", conversationId)\n    .order(\"created_at\", { ascending: false });\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: data as CodeSnippet[] };\n}\n\nexport async function deleteCodeSnippet(\n  snippetId: string,\n): Promise<ActionResult<null>> {\n  const supabase = await createClient();\n\n  const { error } = await supabase\n    .from(\"code_snippets\")\n    .delete()\n    .eq(\"id\", snippetId);\n\n  if (error) {\n    return { success: false, error: error.message };\n  }\n\n  return { success: true, data: null };\n}\n\nexport async function indexRepository(\n  repoId: string,\n): Promise<ActionResult<void>> {\n  const client = await createClient();\n\n  const {\n    data: { user },\n  } = await client.auth.getUser();\n\n  if (!user) {\n    return { success: false, error: \"User not authenticated!\" };\n  }\n\n  const { data: installation, error: installationError } = await client\n    .from(\"github_installations\")\n    .select(\"*\")\n    .eq(\"installed_by\", user.id)\n    .single();\n\n  if (!installation || installationError) {\n    return { success: false, error: \"Github App Installation not found!\" };\n  }\n\n  //fetch repo\n\n  const repoResult = await getRepoWithStatus(repoId);\n\n  if (!repoResult.success) {\n    return { success: false, error: repoResult.error };\n  }\n\n  const repoUrl = repoResult.data.repo_url;\n  const installationId = installation.installation_id;\n\n  // Get the latest version number for this repo\n  const { data: latestDoc } = await client\n    .from(\"documentation\")\n    .select(\"version\")\n    .eq(\"repo_id\", repoId)\n    .order(\"version\", { ascending: false })\n    .limit(1)\n    .single();\n\n  // Increment version (start at 1 if no previous versions)\n  const nextVersion = (latestDoc?.version ?? 0) + 1;\n\n  //mark the repository as indexing in supabase first\n  const { error: updateError } = await client\n    .from(\"repositories\")\n    .update({ index_status: \"indexing\" })\n    .eq(\"id\", repoId);\n\n  if (updateError) {\n    console.error(updateError);\n    return { success: false, error: updateError.message };\n  }\n\n  // Call the backend to start indexing (fire-and-forget)\n  // Don't await or throw errors since this is a long-running operation\n  fetch(`${process.env.BACKEND_URL}/repos/index`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      repo_url: repoUrl,\n      repo_id: repoId,\n      user_id: user.id,\n      installation_id: installationId,\n      branch: \"main\",\n      version: nextVersion,\n    }),\n  }).catch((error) => {\n    // Log the error but don't fail the request\n    console.error(\"Indexing request failed:\", error);\n    // The backend should handle updating the repo status on failure\n  });\n\n  // Return success immediately - the indexing will happen in the background\n  return { success: true, data: undefined };\n}\n"],"names":[],"mappings":";;;;;;;IA4QsB,yBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 555, "column": 0}, "map": {"version":3,"sources":["file:///home/mann/codecompass/src/components/dashboard/repos/new-repo-form.tsx"],"sourcesContent":["\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Separator } from \"@/components/ui/separator\";\nimport {\n  Field,\n  FieldLabel,\n  FieldDescription,\n  FieldError,\n  FieldSet,\n} from \"@/components/ui/field\";\n\nimport { Input } from \"@/components/ui/input\";\n\nimport {\n  Select,\n  SelectTrigger,\n  SelectContent,\n  SelectGroup,\n  SelectLabel,\n  SelectItem,\n  SelectValue,\n} from \"@/components/ui/select\";\n\nimport { useRouter } from \"next/navigation\";\nimport { useState } from \"react\";\nimport {\n  createRepoViaGithub,\n  createRepoViaGitlab,\n  createRepoViaLocalFile,\n} from \"@/lib/services/repoService\";\nimport { useQueryClient } from \"@tanstack/react-query\";\n\ntype NewProjectFormProps = {\n  orgId: string;\n};\n\nexport function NewProjectForm({ orgId }: NewProjectFormProps) {\n  const router = useRouter();\n  const queryClient = useQueryClient();\n\n  const [name, setName] = useState(\"\");\n  const [type, setType] = useState(\"local\");\n  const [uploadedFile, setUploadedFile] = useState<File | null>(null);\n  const [githubUrl, setGithubUrl] = useState(\"\");\n  const [gitlabUrl, setGitlabUrl] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [nameError, setNameError] = useState<string | null>(null);\n\n  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const formData = new FormData(e.currentTarget);\n\n      if (type === \"local\") {\n        // Validate that a file has been uploaded\n        if (!uploadedFile) {\n          setError(\"Please select a .zip file to upload\");\n          setIsLoading(false);\n          return;\n        }\n\n        const result = await createRepoViaLocalFile(formData, orgId);\n\n        if (!result.success) {\n          setError(result.error);\n          setIsLoading(false);\n          return;\n        }\n\n        // Invalidate repositories query to refetch fresh data\n        queryClient.invalidateQueries({ queryKey: [\"repositories\", orgId] });\n\n        router.push(`/dashboard/org/${orgId}`);\n      } else if (type === \"github\") {\n        const result = await createRepoViaGithub(formData, orgId);\n\n        if (!result.success) {\n          if (result.error === \"Name is required!\") {\n            setNameError(result.error);\n            setIsLoading(false);\n            return;\n          }\n          if (result.error === \"Installation Needed\") {\n            // Automatically redirect to GitHub App installation page\n            router.push(`/dashboard/install-github-app?org_id=${orgId}`);\n            return;\n          }\n          setError(result.error);\n          setIsLoading(false);\n          return;\n        }\n\n        // Invalidate repositories query to refetch fresh data\n        queryClient.invalidateQueries({ queryKey: [\"repositories\", orgId] });\n\n        router.push(`/dashboard/org/${orgId}`);\n      } else if (type === \"gitlab\") {\n        const result = await createRepoViaGitlab(formData, orgId);\n\n        if (!result.success) {\n          console.log(result.error);\n          if (result.error === \"Name is required!\") {\n            setNameError(result.error);\n            setIsLoading(false);\n            return;\n          }\n          if (result.error === \"Installation Needed\") {\n            // Redirect to GitLab App installation page\n            router.push(`/dashboard/install-gitlab-app?org_id=${orgId}`);\n          }\n          if (result.error === \"Access required!\") {\n            // Redirect to project selection page\n            router.push(\n              `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/org/${orgId}/gitlab/select-repos`,\n            );\n          }\n          setError(result.error);\n          setIsLoading(false);\n          return;\n        }\n\n        // Invalidate repositories query to refetch fresh data\n        queryClient.invalidateQueries({ queryKey: [\"repositories\", orgId] });\n\n        router.push(`/dashboard/org/${orgId}`);\n      }\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : \"An unexpected error occurred\",\n      );\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col bg-elevated\">\n      <form\n        onSubmit={handleSubmit}\n        className=\"space-y-6 px-5 py-5 border rounded-md\"\n      >\n        {/* Hidden input to ensure type value is submitted */}\n        <input type=\"hidden\" name=\"type\" value={type} />\n\n        <div className=\"flex flex-col gap-1\">\n          <span className=\"text-foreground\">Index a new Repository</span>\n          <span className=\"text-muted-foreground text-xs\">\n            Index a repository to generate documentation and start chatting with\n            the codebase.\n          </span>\n        </div>\n        <Separator />\n\n        <FieldSet>\n          <Field>\n            <FieldLabel htmlFor=\"name\">Name</FieldLabel>\n            <input\n              id=\"name\"\n              name=\"name\"\n              type=\"text\"\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              placeholder=\"Organization name\"\n              required\n              className=\"w-full px-3 py-2 border border-input rounded-md bg-background text-foreground text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent\"\n            />\n            <FieldDescription>\n              Choose a name for the repository.\n            </FieldDescription>\n            <FieldError>{nameError}</FieldError>\n          </Field>\n          <Separator />\n          <Field>\n            <FieldLabel htmlFor=\"type\">Type</FieldLabel>\n            <Select\n              value={type}\n              onValueChange={(value) => {\n                setType(value);\n              }}\n            >\n              <SelectTrigger id=\"type\" name=\"type\">\n                <SelectValue placeholder=\"Select a type\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectGroup>\n                  <SelectLabel>Select a Type</SelectLabel>\n                  <SelectItem value=\"local\">Local</SelectItem>\n                  <SelectItem value=\"github\">GitHub</SelectItem>\n                  <SelectItem value=\"gitlab\">GitLab</SelectItem>\n                </SelectGroup>\n              </SelectContent>\n            </Select>\n            <FieldDescription>Select a repository type</FieldDescription>\n            {type === \"github\" && (\n              <div className=\"flex flex-col gap-3 py-2\">\n                <Separator />\n                <Field className=\"py-2\">\n                  <FieldLabel htmlFor=\"github-url\">GitHub URL</FieldLabel>\n                  <Input\n                    id=\"github-url\"\n                    name=\"github-url\"\n                    type=\"url\"\n                    value={githubUrl}\n                    onChange={(e) => setGithubUrl(e.target.value)}\n                    className=\"w-full px-3 py-2 border border-input rounded-md bg-background text-foreground text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent\"\n                  />\n                  <FieldDescription>\n                    Enter the URL of the GitHub repository.\n                  </FieldDescription>\n                </Field>\n              </div>\n            )}\n            {type === \"gitlab\" && (\n              <div className=\"flex flex-col gap-3 py-2\">\n                <Separator />\n                <Field className=\"py-2\">\n                  <FieldLabel htmlFor=\"gitlab-url\">GitLab URL</FieldLabel>\n                  <Input\n                    id=\"gitlab-url\"\n                    name=\"gitlab-url\"\n                    type=\"url\"\n                    value={gitlabUrl}\n                    onChange={(e) => setGitlabUrl(e.target.value)}\n                    className=\"w-full px-3 py-2 border border-input rounded-md bg-background text-foreground text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent\"\n                  />\n                  <FieldDescription>\n                    Enter the URL of the GitLab repository.\n                  </FieldDescription>\n                </Field>\n              </div>\n            )}\n            {type === \"local\" && (\n              <div className=\"flex flex-col gap-3 py-2\">\n                <Separator />\n                <Field className=\"py-2\">\n                  <FieldLabel htmlFor=\"file\">File (.zip)</FieldLabel>\n                  <Input\n                    id=\"file\"\n                    name=\"file\"\n                    type=\"file\"\n                    accept=\".zip,application/zip\"\n                    onChange={(e) =>\n                      setUploadedFile(e.target.files?.[0] || null)\n                    }\n                    className=\"cursor-pointer file:cursor-pointer file:border file:border-gray-700 file:bg-elevated file:hover:border-gray-600 file:px-4 file:py-1 file:rounded-md file:mr-3 file:transition-colors\"\n                  />\n                  <FieldDescription>\n                    {uploadedFile\n                      ? `Selected: ${uploadedFile.name} (${(uploadedFile.size / 1024 / 1024).toFixed(2)} MB)`\n                      : \"Upload a .zip file of the local repository.\"}\n                  </FieldDescription>\n                  <FieldError>{error}</FieldError>\n                </Field>\n              </div>\n            )}\n          </Field>\n        </FieldSet>\n\n        <Separator />\n\n        <div className=\"flex gap-3\">\n          <Button type=\"submit\" size=\"sm\" disabled={isLoading || !name.trim()}>\n            {isLoading ? \"Creating...\" : \"Create Repository\"}\n          </Button>\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={() => router.back()}\n            disabled={isLoading}\n          >\n            Cancel\n          </Button>\n        </div>\n      </form>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}}]
}