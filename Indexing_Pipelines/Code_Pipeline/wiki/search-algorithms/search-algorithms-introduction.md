# Introduction to Search Algorithms

## What Is It?

Search algorithms are systematic methods used to explore and navigate through various states or configurations in a problem space. In the context of pathfinding and decision-making, these algorithms are crucial for determining optimal routes or solutions within game environments. They enable agents to make informed decisions based on their current state and the desired goal, whether it be collecting items, navigating mazes, or reaching specific positions on a game board.

In this codebase, search algorithms are implemented to facilitate efficient navigation and decision-making for agents within a game. By leveraging various classes and functions, the system can evaluate paths, calculate distances, and determine the best course of action based on the current game state. This functionality is essential for creating intelligent behaviors in game AI, enhancing the overall gameplay experience.

## How It Works

The search algorithms in this codebase are built around several key components that work together to facilitate the search process. At the core of these algorithms are the `SearchProblem` classes, which define the structure of the search scenario and manage the state of the agent. For instance, the `FoodSearchProblem` and `PositionSearchProblem` classes encapsulate the starting position, goal conditions, and methods for generating successor nodes.

### Key Components

1. **Search Nodes**: 
   - The `FoodSearchNode` and `PositionSearchNode` classes represent individual states in their respective search problems. They encapsulate the current position and any relevant information (like remaining food in `FoodSearchNode`). These nodes implement comparison and hashing methods, allowing them to be efficiently stored and compared in data structures.

2. **Distance Calculation**: 
   - The `DistanceFunction` and `DistancePreComputer` classes are responsible for calculating distances between positions on the game board. The `DistanceFunction` class allows for dynamic distance calculations, while `DistancePreComputer` pre-computes distances for efficient retrieval, which is critical for algorithms that require quick access to distance information.

3. **Heuristics**: 
   - Heuristics play a vital role in guiding the search process. Functions like `manhattan_heuristic`, `euclidean_heuristic`, and `null_heuristic` provide estimates of the cost to reach the goal from a given node. These heuristics help prioritize which nodes to explore, improving the efficiency of the search.

4. **Search Algorithms**: 
   - Various search strategies can be implemented using the defined nodes and heuristics. For example, the `random_search` function explores potential solutions using a heuristic and random number generation, while the `maze_tiny_search` function provides a predefined sequence of actions for navigating a specific maze.

### Flow of Execution

The lifecycle of a search algorithm typically begins with the initialization of a `SearchProblem` instance, such as `FoodSearchProblem`. The agent's starting node is created using the `get_starting_node` method, which returns a `FoodSearchNode`. The search process then iteratively explores successor nodes generated by the `get_successor_nodes` method, evaluating each node against the goal conditions using the `is_goal_node` method.

As the search progresses, distance calculations are performed using the `DistanceFunction` or `DistancePreComputer`, and heuristics are applied to guide the exploration. The search continues until a goal node is reached or all possible states have been evaluated.

## Key Classes/Functions

### Classes

- **`FoodSearchNode`**: Represents a state in the food collection task, encapsulating the position and remaining food. It implements comparison methods for efficient storage and retrieval.
  
- **`FoodSearchProblem`**: Models the food collection problem, managing the agent's state, goal conditions, and generating successor nodes.

- **`PositionSearchNode`**: Represents a node in a positional search, encapsulating a position and implementing comparison methods.

- **`PositionSearchProblem`**: Facilitates the search for a specific goal position, managing the starting position and goal conditions.

- **`DistanceFunction`**: Calculates a metric based on positional inputs, allowing for dynamic distance evaluations.

- **`DistancePreComputer`**: Pre-computes distances between positions on a game board, enabling efficient distance queries.

### Functions

- **`manhattan_distance`**: Computes the Manhattan distance between two positions, essential for grid-based pathfinding.

- **`euclidean_distance`**: Calculates the Euclidean distance, providing another metric for evaluating distances.

- **`null_heuristic`**: A trivial heuristic that always returns zero, indicating no preference for paths.

- **`random_search`**: Implements a random search strategy, exploring potential solutions until a goal is found.

- **`maze_tiny_search`**: Provides a predefined sequence of actions for navigating a specific maze, demonstrating a structured approach to solving search problems.

## Examples

### Food Collection Example

In a game where an agent must collect food items, the `FoodSearchProblem` class can be instantiated with the agent's starting position and the locations of food items on the board. The search process begins by calling `get_starting_node`, which creates a `FoodSearchNode`. The agent then explores possible actions using `get_successor_nodes`, evaluating each node with `is_goal_node` to determine if all food has been collected.

### Maze Navigation Example

For navigating a maze, the `maze_tiny_search` function can be employed to generate a sequence of actions. This function returns a `SearchSolution` object that includes the actions needed to traverse the maze, demonstrating how predefined paths can simplify navigation tasks.

By utilizing these classes and functions, developers can implement robust search algorithms that enhance the AI capabilities of game agents, enabling them to navigate complex environments and make strategic decisions effectively.